Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> progv
Rule 1     progv -> element progv
Rule 2     progv -> <empty>
Rule 3     element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt
Rule 4     element -> sstmt
Rule 5     optparams -> params
Rule 6     optparams -> <empty>
Rule 7     params -> IDENTIFIER COMMA params
Rule 8     params -> IDENTIFIER
Rule 9     compoundstmt -> LBRACE stmts RBRACE
Rule 10    stmts -> sstmt stmts
Rule 11    stmt_or_compound -> sstmt
Rule 12    stmt_or_compound -> compoundstmt
Rule 13    optsemi -> <empty>
Rule 14    optsemi -> SEMICOLON
Rule 15    stmts -> <empty>
Rule 16    sstmt -> IF exp stmt_or_compound optsemi
Rule 17    sstmt -> WHILE exp compoundstmt optsemi
Rule 18    sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi
Rule 19    sstmt -> IDENTIFIER EQUAL exp optsemi
Rule 20    sstmt -> RETURN exp optsemi
Rule 21    sstmt -> VAR IDENTIFIER EQUAL exp optsemi
Rule 22    sstmt -> exp optsemi
Rule 23    exp -> IDENTIFIER
Rule 24    exp -> NUMBER
Rule 25    exp -> STRING
Rule 26    exp -> TRUE
Rule 27    exp -> FALSE
Rule 28    exp -> LOGICAL_NOT exp
Rule 29    exp -> LPAREN exp RPAREN
Rule 30    exp -> FUNCTION LPAREN optparams RPAREN compoundstmt
Rule 31    exp -> exp LOGICAL_OR exp
Rule 32    exp -> exp LOGICAL_AND exp
Rule 33    exp -> exp LOGICAL_EQUAL exp
Rule 34    exp -> exp LT exp
Rule 35    exp -> exp GT exp
Rule 36    exp -> exp LE exp
Rule 37    exp -> exp GE exp
Rule 38    exp -> exp PLUS exp
Rule 39    exp -> exp MINUS exp
Rule 40    exp -> exp TIMES exp
Rule 41    exp -> exp DIVIDE exp
Rule 42    exp -> exp POWER exp
Rule 43    exp -> exp MOD exp
Rule 44    exp -> IDENTIFIER LPAREN optargs RPAREN
Rule 45    optargs -> args
Rule 46    optargs -> <empty>
Rule 47    args -> exp COMMA args
Rule 48    args -> exp

Terminals, with rules where they appear

COMMA                : 7 47
DIVIDE               : 41
ELSE                 : 18
EQUAL                : 19 21
FALSE                : 27
FUNCTION             : 3 30
GE                   : 37
GT                   : 35
IDENTIFIER           : 3 7 8 19 21 23 44
IF                   : 16 18
LBRACE               : 9
LE                   : 36
LOGICAL_AND          : 32
LOGICAL_EQUAL        : 33
LOGICAL_NOT          : 28
LOGICAL_OR           : 31
LPAREN               : 3 29 30 44
LT                   : 34
MINUS                : 39
MOD                  : 43
NUMBER               : 24
PLUS                 : 38
POWER                : 42
RBRACE               : 9
RETURN               : 20
RPAREN               : 3 29 30 44
SEMICOLON            : 14
STRING               : 25
TIMES                : 40
TRUE                 : 26
VAR                  : 21
WHILE                : 17
error                : 

Nonterminals, with rules where they appear

args                 : 45 47
compoundstmt         : 3 12 17 18 30
element              : 1
exp                  : 16 17 18 19 20 21 22 28 29 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 47 48
optargs              : 44
optparams            : 3 30
optsemi              : 16 17 18 19 20 21 22
params               : 5 7
progv                : 1 0
sstmt                : 4 10 11
stmt_or_compound     : 16 18
stmts                : 9 10

Parsing method: LALR

state 0

    (0) S' -> . progv
    (1) progv -> . element progv
    (2) progv -> .
    (3) element -> . FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt
    (4) element -> . sstmt
    (16) sstmt -> . IF exp stmt_or_compound optsemi
    (17) sstmt -> . WHILE exp compoundstmt optsemi
    (18) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (19) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (20) sstmt -> . RETURN exp optsemi
    (21) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (22) sstmt -> . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    $end            reduce using rule 2 (progv -> .)
    FUNCTION        shift and go to state 6
    IF              shift and go to state 13
    WHILE           shift and go to state 2
    IDENTIFIER      shift and go to state 5
    RETURN          shift and go to state 1
    VAR             shift and go to state 11
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10

    progv                          shift and go to state 8
    sstmt                          shift and go to state 4
    element                        shift and go to state 15
    exp                            shift and go to state 16

state 1

    (20) sstmt -> RETURN . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 19

state 2

    (17) sstmt -> WHILE . exp compoundstmt optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 20

state 3

    (26) exp -> TRUE .

    LOGICAL_OR      reduce using rule 26 (exp -> TRUE .)
    LOGICAL_AND     reduce using rule 26 (exp -> TRUE .)
    LOGICAL_EQUAL   reduce using rule 26 (exp -> TRUE .)
    LT              reduce using rule 26 (exp -> TRUE .)
    GT              reduce using rule 26 (exp -> TRUE .)
    LE              reduce using rule 26 (exp -> TRUE .)
    GE              reduce using rule 26 (exp -> TRUE .)
    PLUS            reduce using rule 26 (exp -> TRUE .)
    MINUS           reduce using rule 26 (exp -> TRUE .)
    TIMES           reduce using rule 26 (exp -> TRUE .)
    DIVIDE          reduce using rule 26 (exp -> TRUE .)
    POWER           reduce using rule 26 (exp -> TRUE .)
    MOD             reduce using rule 26 (exp -> TRUE .)
    SEMICOLON       reduce using rule 26 (exp -> TRUE .)
    FUNCTION        reduce using rule 26 (exp -> TRUE .)
    IF              reduce using rule 26 (exp -> TRUE .)
    WHILE           reduce using rule 26 (exp -> TRUE .)
    IDENTIFIER      reduce using rule 26 (exp -> TRUE .)
    RETURN          reduce using rule 26 (exp -> TRUE .)
    VAR             reduce using rule 26 (exp -> TRUE .)
    NUMBER          reduce using rule 26 (exp -> TRUE .)
    STRING          reduce using rule 26 (exp -> TRUE .)
    TRUE            reduce using rule 26 (exp -> TRUE .)
    FALSE           reduce using rule 26 (exp -> TRUE .)
    LOGICAL_NOT     reduce using rule 26 (exp -> TRUE .)
    LPAREN          reduce using rule 26 (exp -> TRUE .)
    $end            reduce using rule 26 (exp -> TRUE .)
    RBRACE          reduce using rule 26 (exp -> TRUE .)
    RPAREN          reduce using rule 26 (exp -> TRUE .)
    LBRACE          reduce using rule 26 (exp -> TRUE .)
    COMMA           reduce using rule 26 (exp -> TRUE .)


state 4

    (4) element -> sstmt .

    FUNCTION        reduce using rule 4 (element -> sstmt .)
    IF              reduce using rule 4 (element -> sstmt .)
    WHILE           reduce using rule 4 (element -> sstmt .)
    IDENTIFIER      reduce using rule 4 (element -> sstmt .)
    RETURN          reduce using rule 4 (element -> sstmt .)
    VAR             reduce using rule 4 (element -> sstmt .)
    NUMBER          reduce using rule 4 (element -> sstmt .)
    STRING          reduce using rule 4 (element -> sstmt .)
    TRUE            reduce using rule 4 (element -> sstmt .)
    FALSE           reduce using rule 4 (element -> sstmt .)
    LOGICAL_NOT     reduce using rule 4 (element -> sstmt .)
    LPAREN          reduce using rule 4 (element -> sstmt .)
    $end            reduce using rule 4 (element -> sstmt .)


state 5

    (19) sstmt -> IDENTIFIER . EQUAL exp optsemi
    (23) exp -> IDENTIFIER .
    (44) exp -> IDENTIFIER . LPAREN optargs RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    EQUAL           shift and go to state 21
    LOGICAL_OR      reduce using rule 23 (exp -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 23 (exp -> IDENTIFIER .)
    LOGICAL_EQUAL   reduce using rule 23 (exp -> IDENTIFIER .)
    LT              reduce using rule 23 (exp -> IDENTIFIER .)
    GT              reduce using rule 23 (exp -> IDENTIFIER .)
    LE              reduce using rule 23 (exp -> IDENTIFIER .)
    GE              reduce using rule 23 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 23 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 23 (exp -> IDENTIFIER .)
    TIMES           reduce using rule 23 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 23 (exp -> IDENTIFIER .)
    POWER           reduce using rule 23 (exp -> IDENTIFIER .)
    MOD             reduce using rule 23 (exp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 23 (exp -> IDENTIFIER .)
    FUNCTION        reduce using rule 23 (exp -> IDENTIFIER .)
    IF              reduce using rule 23 (exp -> IDENTIFIER .)
    WHILE           reduce using rule 23 (exp -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 23 (exp -> IDENTIFIER .)
    RETURN          reduce using rule 23 (exp -> IDENTIFIER .)
    VAR             reduce using rule 23 (exp -> IDENTIFIER .)
    NUMBER          reduce using rule 23 (exp -> IDENTIFIER .)
    STRING          reduce using rule 23 (exp -> IDENTIFIER .)
    TRUE            reduce using rule 23 (exp -> IDENTIFIER .)
    FALSE           reduce using rule 23 (exp -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 23 (exp -> IDENTIFIER .)
    $end            reduce using rule 23 (exp -> IDENTIFIER .)
    RBRACE          reduce using rule 23 (exp -> IDENTIFIER .)
    LPAREN          shift and go to state 22

  ! LPAREN          [ reduce using rule 23 (exp -> IDENTIFIER .) ]


state 6

    (3) element -> FUNCTION . IDENTIFIER LPAREN optparams RPAREN compoundstmt
    (30) exp -> FUNCTION . LPAREN optparams RPAREN compoundstmt

    IDENTIFIER      shift and go to state 24
    LPAREN          shift and go to state 23


state 7

    (25) exp -> STRING .

    LOGICAL_OR      reduce using rule 25 (exp -> STRING .)
    LOGICAL_AND     reduce using rule 25 (exp -> STRING .)
    LOGICAL_EQUAL   reduce using rule 25 (exp -> STRING .)
    LT              reduce using rule 25 (exp -> STRING .)
    GT              reduce using rule 25 (exp -> STRING .)
    LE              reduce using rule 25 (exp -> STRING .)
    GE              reduce using rule 25 (exp -> STRING .)
    PLUS            reduce using rule 25 (exp -> STRING .)
    MINUS           reduce using rule 25 (exp -> STRING .)
    TIMES           reduce using rule 25 (exp -> STRING .)
    DIVIDE          reduce using rule 25 (exp -> STRING .)
    POWER           reduce using rule 25 (exp -> STRING .)
    MOD             reduce using rule 25 (exp -> STRING .)
    SEMICOLON       reduce using rule 25 (exp -> STRING .)
    FUNCTION        reduce using rule 25 (exp -> STRING .)
    IF              reduce using rule 25 (exp -> STRING .)
    WHILE           reduce using rule 25 (exp -> STRING .)
    IDENTIFIER      reduce using rule 25 (exp -> STRING .)
    RETURN          reduce using rule 25 (exp -> STRING .)
    VAR             reduce using rule 25 (exp -> STRING .)
    NUMBER          reduce using rule 25 (exp -> STRING .)
    STRING          reduce using rule 25 (exp -> STRING .)
    TRUE            reduce using rule 25 (exp -> STRING .)
    FALSE           reduce using rule 25 (exp -> STRING .)
    LOGICAL_NOT     reduce using rule 25 (exp -> STRING .)
    LPAREN          reduce using rule 25 (exp -> STRING .)
    $end            reduce using rule 25 (exp -> STRING .)
    RBRACE          reduce using rule 25 (exp -> STRING .)
    RPAREN          reduce using rule 25 (exp -> STRING .)
    LBRACE          reduce using rule 25 (exp -> STRING .)
    COMMA           reduce using rule 25 (exp -> STRING .)


state 8

    (0) S' -> progv .



state 9

    (24) exp -> NUMBER .

    LOGICAL_OR      reduce using rule 24 (exp -> NUMBER .)
    LOGICAL_AND     reduce using rule 24 (exp -> NUMBER .)
    LOGICAL_EQUAL   reduce using rule 24 (exp -> NUMBER .)
    LT              reduce using rule 24 (exp -> NUMBER .)
    GT              reduce using rule 24 (exp -> NUMBER .)
    LE              reduce using rule 24 (exp -> NUMBER .)
    GE              reduce using rule 24 (exp -> NUMBER .)
    PLUS            reduce using rule 24 (exp -> NUMBER .)
    MINUS           reduce using rule 24 (exp -> NUMBER .)
    TIMES           reduce using rule 24 (exp -> NUMBER .)
    DIVIDE          reduce using rule 24 (exp -> NUMBER .)
    POWER           reduce using rule 24 (exp -> NUMBER .)
    MOD             reduce using rule 24 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 24 (exp -> NUMBER .)
    FUNCTION        reduce using rule 24 (exp -> NUMBER .)
    IF              reduce using rule 24 (exp -> NUMBER .)
    WHILE           reduce using rule 24 (exp -> NUMBER .)
    IDENTIFIER      reduce using rule 24 (exp -> NUMBER .)
    RETURN          reduce using rule 24 (exp -> NUMBER .)
    VAR             reduce using rule 24 (exp -> NUMBER .)
    NUMBER          reduce using rule 24 (exp -> NUMBER .)
    STRING          reduce using rule 24 (exp -> NUMBER .)
    TRUE            reduce using rule 24 (exp -> NUMBER .)
    FALSE           reduce using rule 24 (exp -> NUMBER .)
    LOGICAL_NOT     reduce using rule 24 (exp -> NUMBER .)
    LPAREN          reduce using rule 24 (exp -> NUMBER .)
    $end            reduce using rule 24 (exp -> NUMBER .)
    RBRACE          reduce using rule 24 (exp -> NUMBER .)
    RPAREN          reduce using rule 24 (exp -> NUMBER .)
    LBRACE          reduce using rule 24 (exp -> NUMBER .)
    COMMA           reduce using rule 24 (exp -> NUMBER .)


state 10

    (29) exp -> LPAREN . exp RPAREN
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 25

state 11

    (21) sstmt -> VAR . IDENTIFIER EQUAL exp optsemi

    IDENTIFIER      shift and go to state 26


state 12

    (28) exp -> LOGICAL_NOT . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 27

state 13

    (16) sstmt -> IF . exp stmt_or_compound optsemi
    (18) sstmt -> IF . exp compoundstmt ELSE stmt_or_compound optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 28

state 14

    (27) exp -> FALSE .

    LOGICAL_OR      reduce using rule 27 (exp -> FALSE .)
    LOGICAL_AND     reduce using rule 27 (exp -> FALSE .)
    LOGICAL_EQUAL   reduce using rule 27 (exp -> FALSE .)
    LT              reduce using rule 27 (exp -> FALSE .)
    GT              reduce using rule 27 (exp -> FALSE .)
    LE              reduce using rule 27 (exp -> FALSE .)
    GE              reduce using rule 27 (exp -> FALSE .)
    PLUS            reduce using rule 27 (exp -> FALSE .)
    MINUS           reduce using rule 27 (exp -> FALSE .)
    TIMES           reduce using rule 27 (exp -> FALSE .)
    DIVIDE          reduce using rule 27 (exp -> FALSE .)
    POWER           reduce using rule 27 (exp -> FALSE .)
    MOD             reduce using rule 27 (exp -> FALSE .)
    SEMICOLON       reduce using rule 27 (exp -> FALSE .)
    FUNCTION        reduce using rule 27 (exp -> FALSE .)
    IF              reduce using rule 27 (exp -> FALSE .)
    WHILE           reduce using rule 27 (exp -> FALSE .)
    IDENTIFIER      reduce using rule 27 (exp -> FALSE .)
    RETURN          reduce using rule 27 (exp -> FALSE .)
    VAR             reduce using rule 27 (exp -> FALSE .)
    NUMBER          reduce using rule 27 (exp -> FALSE .)
    STRING          reduce using rule 27 (exp -> FALSE .)
    TRUE            reduce using rule 27 (exp -> FALSE .)
    FALSE           reduce using rule 27 (exp -> FALSE .)
    LOGICAL_NOT     reduce using rule 27 (exp -> FALSE .)
    LPAREN          reduce using rule 27 (exp -> FALSE .)
    $end            reduce using rule 27 (exp -> FALSE .)
    RBRACE          reduce using rule 27 (exp -> FALSE .)
    RPAREN          reduce using rule 27 (exp -> FALSE .)
    LBRACE          reduce using rule 27 (exp -> FALSE .)
    COMMA           reduce using rule 27 (exp -> FALSE .)


state 15

    (1) progv -> element . progv
    (1) progv -> . element progv
    (2) progv -> .
    (3) element -> . FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt
    (4) element -> . sstmt
    (16) sstmt -> . IF exp stmt_or_compound optsemi
    (17) sstmt -> . WHILE exp compoundstmt optsemi
    (18) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (19) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (20) sstmt -> . RETURN exp optsemi
    (21) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (22) sstmt -> . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    $end            reduce using rule 2 (progv -> .)
    FUNCTION        shift and go to state 6
    IF              shift and go to state 13
    WHILE           shift and go to state 2
    IDENTIFIER      shift and go to state 5
    RETURN          shift and go to state 1
    VAR             shift and go to state 11
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10

    progv                          shift and go to state 29
    sstmt                          shift and go to state 4
    element                        shift and go to state 15
    exp                            shift and go to state 16

state 16

    (22) sstmt -> exp . optsemi
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 34

state 17

    (23) exp -> IDENTIFIER .
    (44) exp -> IDENTIFIER . LPAREN optargs RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LOGICAL_OR      reduce using rule 23 (exp -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 23 (exp -> IDENTIFIER .)
    LOGICAL_EQUAL   reduce using rule 23 (exp -> IDENTIFIER .)
    LT              reduce using rule 23 (exp -> IDENTIFIER .)
    GT              reduce using rule 23 (exp -> IDENTIFIER .)
    LE              reduce using rule 23 (exp -> IDENTIFIER .)
    GE              reduce using rule 23 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 23 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 23 (exp -> IDENTIFIER .)
    TIMES           reduce using rule 23 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 23 (exp -> IDENTIFIER .)
    POWER           reduce using rule 23 (exp -> IDENTIFIER .)
    MOD             reduce using rule 23 (exp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 23 (exp -> IDENTIFIER .)
    FUNCTION        reduce using rule 23 (exp -> IDENTIFIER .)
    IF              reduce using rule 23 (exp -> IDENTIFIER .)
    WHILE           reduce using rule 23 (exp -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 23 (exp -> IDENTIFIER .)
    RETURN          reduce using rule 23 (exp -> IDENTIFIER .)
    VAR             reduce using rule 23 (exp -> IDENTIFIER .)
    NUMBER          reduce using rule 23 (exp -> IDENTIFIER .)
    STRING          reduce using rule 23 (exp -> IDENTIFIER .)
    TRUE            reduce using rule 23 (exp -> IDENTIFIER .)
    FALSE           reduce using rule 23 (exp -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 23 (exp -> IDENTIFIER .)
    $end            reduce using rule 23 (exp -> IDENTIFIER .)
    RBRACE          reduce using rule 23 (exp -> IDENTIFIER .)
    RPAREN          reduce using rule 23 (exp -> IDENTIFIER .)
    LBRACE          reduce using rule 23 (exp -> IDENTIFIER .)
    COMMA           reduce using rule 23 (exp -> IDENTIFIER .)
    LPAREN          shift and go to state 22

  ! LPAREN          [ reduce using rule 23 (exp -> IDENTIFIER .) ]


state 18

    (30) exp -> FUNCTION . LPAREN optparams RPAREN compoundstmt

    LPAREN          shift and go to state 23


state 19

    (20) sstmt -> RETURN exp . optsemi
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 45

state 20

    (17) sstmt -> WHILE exp . compoundstmt optsemi
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp
    (9) compoundstmt -> . LBRACE stmts RBRACE

    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44
    LBRACE          shift and go to state 46

    compoundstmt                   shift and go to state 47

state 21

    (19) sstmt -> IDENTIFIER EQUAL . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 48

state 22

    (44) exp -> IDENTIFIER LPAREN . optargs RPAREN
    (45) optargs -> . args
    (46) optargs -> .
    (47) args -> . exp COMMA args
    (48) args -> . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    RPAREN          reduce using rule 46 (optargs -> .)
    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    args                           shift and go to state 50
    exp                            shift and go to state 51
    optargs                        shift and go to state 49

state 23

    (30) exp -> FUNCTION LPAREN . optparams RPAREN compoundstmt
    (5) optparams -> . params
    (6) optparams -> .
    (7) params -> . IDENTIFIER COMMA params
    (8) params -> . IDENTIFIER

    RPAREN          reduce using rule 6 (optparams -> .)
    IDENTIFIER      shift and go to state 53

    params                         shift and go to state 52
    optparams                      shift and go to state 54

state 24

    (3) element -> FUNCTION IDENTIFIER . LPAREN optparams RPAREN compoundstmt

    LPAREN          shift and go to state 55


state 25

    (29) exp -> LPAREN exp . RPAREN
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    RPAREN          shift and go to state 56
    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44


state 26

    (21) sstmt -> VAR IDENTIFIER . EQUAL exp optsemi

    EQUAL           shift and go to state 57


state 27

    (28) exp -> LOGICAL_NOT exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LOGICAL_AND     reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LOGICAL_EQUAL   reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LT              reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    GT              reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LE              reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    GE              reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    PLUS            reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    MINUS           reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    TIMES           reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    DIVIDE          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    POWER           reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    MOD             reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    SEMICOLON       reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    FUNCTION        reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    IF              reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    WHILE           reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    IDENTIFIER      reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    RETURN          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    VAR             reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    NUMBER          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    STRING          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    TRUE            reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    FALSE           reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LOGICAL_NOT     reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LPAREN          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    $end            reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    RBRACE          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    RPAREN          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    LBRACE          reduce using rule 28 (exp -> LOGICAL_NOT exp .)
    COMMA           reduce using rule 28 (exp -> LOGICAL_NOT exp .)

  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 33 ]
  ! MOD             [ shift and go to state 44 ]


state 28

    (16) sstmt -> IF exp . stmt_or_compound optsemi
    (18) sstmt -> IF exp . compoundstmt ELSE stmt_or_compound optsemi
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp
    (11) stmt_or_compound -> . sstmt
    (12) stmt_or_compound -> . compoundstmt
    (9) compoundstmt -> . LBRACE stmts RBRACE
    (16) sstmt -> . IF exp stmt_or_compound optsemi
    (17) sstmt -> . WHILE exp compoundstmt optsemi
    (18) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (19) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (20) sstmt -> . RETURN exp optsemi
    (21) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (22) sstmt -> . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44
    LBRACE          shift and go to state 46
    IF              shift and go to state 13
    WHILE           shift and go to state 2
    IDENTIFIER      shift and go to state 5
    RETURN          shift and go to state 1
    VAR             shift and go to state 11
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    stmt_or_compound               shift and go to state 59
    sstmt                          shift and go to state 58
    exp                            shift and go to state 16
    compoundstmt                   shift and go to state 60

state 29

    (1) progv -> element progv .

    $end            reduce using rule 1 (progv -> element progv .)


state 30

    (33) exp -> exp LOGICAL_EQUAL . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 61

state 31

    (35) exp -> exp GT . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 62

state 32

    (41) exp -> exp DIVIDE . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 63

state 33

    (42) exp -> exp POWER . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 64

state 34

    (22) sstmt -> exp optsemi .

    SEMICOLON       reduce using rule 22 (sstmt -> exp optsemi .)
    FUNCTION        reduce using rule 22 (sstmt -> exp optsemi .)
    IF              reduce using rule 22 (sstmt -> exp optsemi .)
    WHILE           reduce using rule 22 (sstmt -> exp optsemi .)
    IDENTIFIER      reduce using rule 22 (sstmt -> exp optsemi .)
    RETURN          reduce using rule 22 (sstmt -> exp optsemi .)
    VAR             reduce using rule 22 (sstmt -> exp optsemi .)
    NUMBER          reduce using rule 22 (sstmt -> exp optsemi .)
    STRING          reduce using rule 22 (sstmt -> exp optsemi .)
    TRUE            reduce using rule 22 (sstmt -> exp optsemi .)
    FALSE           reduce using rule 22 (sstmt -> exp optsemi .)
    LOGICAL_NOT     reduce using rule 22 (sstmt -> exp optsemi .)
    LPAREN          reduce using rule 22 (sstmt -> exp optsemi .)
    $end            reduce using rule 22 (sstmt -> exp optsemi .)
    RBRACE          reduce using rule 22 (sstmt -> exp optsemi .)


state 35

    (37) exp -> exp GE . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 65

state 36

    (40) exp -> exp TIMES . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 66

state 37

    (31) exp -> exp LOGICAL_OR . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 67

state 38

    (34) exp -> exp LT . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 68

state 39

    (36) exp -> exp LE . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 69

state 40

    (32) exp -> exp LOGICAL_AND . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 70

state 41

    (38) exp -> exp PLUS . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 71

state 42

    (39) exp -> exp MINUS . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 72

state 43

    (14) optsemi -> SEMICOLON .

    FUNCTION        reduce using rule 14 (optsemi -> SEMICOLON .)
    IF              reduce using rule 14 (optsemi -> SEMICOLON .)
    WHILE           reduce using rule 14 (optsemi -> SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (optsemi -> SEMICOLON .)
    RETURN          reduce using rule 14 (optsemi -> SEMICOLON .)
    VAR             reduce using rule 14 (optsemi -> SEMICOLON .)
    NUMBER          reduce using rule 14 (optsemi -> SEMICOLON .)
    STRING          reduce using rule 14 (optsemi -> SEMICOLON .)
    TRUE            reduce using rule 14 (optsemi -> SEMICOLON .)
    FALSE           reduce using rule 14 (optsemi -> SEMICOLON .)
    LOGICAL_NOT     reduce using rule 14 (optsemi -> SEMICOLON .)
    LPAREN          reduce using rule 14 (optsemi -> SEMICOLON .)
    $end            reduce using rule 14 (optsemi -> SEMICOLON .)
    SEMICOLON       reduce using rule 14 (optsemi -> SEMICOLON .)
    RBRACE          reduce using rule 14 (optsemi -> SEMICOLON .)


state 44

    (43) exp -> exp MOD . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 73

state 45

    (20) sstmt -> RETURN exp optsemi .

    SEMICOLON       reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    FUNCTION        reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    IF              reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    WHILE           reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    IDENTIFIER      reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    RETURN          reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    VAR             reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    NUMBER          reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    STRING          reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    TRUE            reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    FALSE           reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    LOGICAL_NOT     reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    LPAREN          reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    $end            reduce using rule 20 (sstmt -> RETURN exp optsemi .)
    RBRACE          reduce using rule 20 (sstmt -> RETURN exp optsemi .)


state 46

    (9) compoundstmt -> LBRACE . stmts RBRACE
    (10) stmts -> . sstmt stmts
    (15) stmts -> .
    (16) sstmt -> . IF exp stmt_or_compound optsemi
    (17) sstmt -> . WHILE exp compoundstmt optsemi
    (18) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (19) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (20) sstmt -> . RETURN exp optsemi
    (21) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (22) sstmt -> . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    RBRACE          reduce using rule 15 (stmts -> .)
    IF              shift and go to state 13
    WHILE           shift and go to state 2
    IDENTIFIER      shift and go to state 5
    RETURN          shift and go to state 1
    VAR             shift and go to state 11
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    stmts                          shift and go to state 74
    sstmt                          shift and go to state 75
    exp                            shift and go to state 16

state 47

    (17) sstmt -> WHILE exp compoundstmt . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 76

state 48

    (19) sstmt -> IDENTIFIER EQUAL exp . optsemi
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 77

state 49

    (44) exp -> IDENTIFIER LPAREN optargs . RPAREN

    RPAREN          shift and go to state 78


state 50

    (45) optargs -> args .

    RPAREN          reduce using rule 45 (optargs -> args .)


state 51

    (47) args -> exp . COMMA args
    (48) args -> exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    COMMA           shift and go to state 79
    RPAREN          reduce using rule 48 (args -> exp .)
    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44


state 52

    (5) optparams -> params .

    RPAREN          reduce using rule 5 (optparams -> params .)


state 53

    (7) params -> IDENTIFIER . COMMA params
    (8) params -> IDENTIFIER .

    COMMA           shift and go to state 80
    RPAREN          reduce using rule 8 (params -> IDENTIFIER .)


state 54

    (30) exp -> FUNCTION LPAREN optparams . RPAREN compoundstmt

    RPAREN          shift and go to state 81


state 55

    (3) element -> FUNCTION IDENTIFIER LPAREN . optparams RPAREN compoundstmt
    (5) optparams -> . params
    (6) optparams -> .
    (7) params -> . IDENTIFIER COMMA params
    (8) params -> . IDENTIFIER

    RPAREN          reduce using rule 6 (optparams -> .)
    IDENTIFIER      shift and go to state 53

    params                         shift and go to state 52
    optparams                      shift and go to state 82

state 56

    (29) exp -> LPAREN exp RPAREN .

    LOGICAL_OR      reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LOGICAL_AND     reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LOGICAL_EQUAL   reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    FUNCTION        reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    IF              reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    WHILE           reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    IDENTIFIER      reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    RETURN          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    VAR             reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    NUMBER          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    STRING          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    TRUE            reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    FALSE           reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LOGICAL_NOT     reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    $end            reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    RBRACE          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    LBRACE          reduce using rule 29 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 29 (exp -> LPAREN exp RPAREN .)


state 57

    (21) sstmt -> VAR IDENTIFIER EQUAL . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    exp                            shift and go to state 83

state 58

    (11) stmt_or_compound -> sstmt .

    SEMICOLON       reduce using rule 11 (stmt_or_compound -> sstmt .)
    FUNCTION        reduce using rule 11 (stmt_or_compound -> sstmt .)
    IF              reduce using rule 11 (stmt_or_compound -> sstmt .)
    WHILE           reduce using rule 11 (stmt_or_compound -> sstmt .)
    IDENTIFIER      reduce using rule 11 (stmt_or_compound -> sstmt .)
    RETURN          reduce using rule 11 (stmt_or_compound -> sstmt .)
    VAR             reduce using rule 11 (stmt_or_compound -> sstmt .)
    NUMBER          reduce using rule 11 (stmt_or_compound -> sstmt .)
    STRING          reduce using rule 11 (stmt_or_compound -> sstmt .)
    TRUE            reduce using rule 11 (stmt_or_compound -> sstmt .)
    FALSE           reduce using rule 11 (stmt_or_compound -> sstmt .)
    LOGICAL_NOT     reduce using rule 11 (stmt_or_compound -> sstmt .)
    LPAREN          reduce using rule 11 (stmt_or_compound -> sstmt .)
    $end            reduce using rule 11 (stmt_or_compound -> sstmt .)
    RBRACE          reduce using rule 11 (stmt_or_compound -> sstmt .)


state 59

    (16) sstmt -> IF exp stmt_or_compound . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 84

state 60

    (18) sstmt -> IF exp compoundstmt . ELSE stmt_or_compound optsemi
    (12) stmt_or_compound -> compoundstmt .

    ELSE            shift and go to state 85
    SEMICOLON       reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FUNCTION        reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IF              reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    WHILE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IDENTIFIER      reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RETURN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    VAR             reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    NUMBER          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    STRING          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    TRUE            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FALSE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LOGICAL_NOT     reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LPAREN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    $end            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RBRACE          reduce using rule 12 (stmt_or_compound -> compoundstmt .)


state 61

    (33) exp -> exp LOGICAL_EQUAL exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_AND     reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_EQUAL   reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    SEMICOLON       reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    FUNCTION        reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    IF              reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    WHILE           reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    IDENTIFIER      reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    RETURN          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    VAR             reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    NUMBER          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    STRING          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    TRUE            reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    FALSE           reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_NOT     reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    LPAREN          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    $end            reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    RBRACE          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    RPAREN          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    LBRACE          reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    COMMA           reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .)
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! LT              [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! GT              [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! LE              [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! GE              [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! PLUS            [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! POWER           [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! MOD             [ reduce using rule 33 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]


state 62

    (35) exp -> exp GT exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 35 (exp -> exp GT exp .)
    LOGICAL_AND     reduce using rule 35 (exp -> exp GT exp .)
    LOGICAL_EQUAL   reduce using rule 35 (exp -> exp GT exp .)
    LT              reduce using rule 35 (exp -> exp GT exp .)
    GT              reduce using rule 35 (exp -> exp GT exp .)
    LE              reduce using rule 35 (exp -> exp GT exp .)
    GE              reduce using rule 35 (exp -> exp GT exp .)
    SEMICOLON       reduce using rule 35 (exp -> exp GT exp .)
    FUNCTION        reduce using rule 35 (exp -> exp GT exp .)
    IF              reduce using rule 35 (exp -> exp GT exp .)
    WHILE           reduce using rule 35 (exp -> exp GT exp .)
    IDENTIFIER      reduce using rule 35 (exp -> exp GT exp .)
    RETURN          reduce using rule 35 (exp -> exp GT exp .)
    VAR             reduce using rule 35 (exp -> exp GT exp .)
    NUMBER          reduce using rule 35 (exp -> exp GT exp .)
    STRING          reduce using rule 35 (exp -> exp GT exp .)
    TRUE            reduce using rule 35 (exp -> exp GT exp .)
    FALSE           reduce using rule 35 (exp -> exp GT exp .)
    LOGICAL_NOT     reduce using rule 35 (exp -> exp GT exp .)
    LPAREN          reduce using rule 35 (exp -> exp GT exp .)
    $end            reduce using rule 35 (exp -> exp GT exp .)
    RBRACE          reduce using rule 35 (exp -> exp GT exp .)
    RPAREN          reduce using rule 35 (exp -> exp GT exp .)
    LBRACE          reduce using rule 35 (exp -> exp GT exp .)
    COMMA           reduce using rule 35 (exp -> exp GT exp .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! PLUS            [ reduce using rule 35 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 35 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 35 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 35 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 35 (exp -> exp GT exp .) ]
  ! MOD             [ reduce using rule 35 (exp -> exp GT exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]


state 63

    (41) exp -> exp DIVIDE exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 41 (exp -> exp DIVIDE exp .)
    LOGICAL_AND     reduce using rule 41 (exp -> exp DIVIDE exp .)
    LOGICAL_EQUAL   reduce using rule 41 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 41 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 41 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 41 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 41 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 41 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 41 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 41 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 41 (exp -> exp DIVIDE exp .)
    MOD             reduce using rule 41 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 41 (exp -> exp DIVIDE exp .)
    FUNCTION        reduce using rule 41 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 41 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 41 (exp -> exp DIVIDE exp .)
    IDENTIFIER      reduce using rule 41 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 41 (exp -> exp DIVIDE exp .)
    VAR             reduce using rule 41 (exp -> exp DIVIDE exp .)
    NUMBER          reduce using rule 41 (exp -> exp DIVIDE exp .)
    STRING          reduce using rule 41 (exp -> exp DIVIDE exp .)
    TRUE            reduce using rule 41 (exp -> exp DIVIDE exp .)
    FALSE           reduce using rule 41 (exp -> exp DIVIDE exp .)
    LOGICAL_NOT     reduce using rule 41 (exp -> exp DIVIDE exp .)
    LPAREN          reduce using rule 41 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 41 (exp -> exp DIVIDE exp .)
    RBRACE          reduce using rule 41 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 41 (exp -> exp DIVIDE exp .)
    LBRACE          reduce using rule 41 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 41 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 33

  ! POWER           [ reduce using rule 41 (exp -> exp DIVIDE exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! MOD             [ shift and go to state 44 ]


state 64

    (42) exp -> exp POWER exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 42 (exp -> exp POWER exp .)
    LOGICAL_AND     reduce using rule 42 (exp -> exp POWER exp .)
    LOGICAL_EQUAL   reduce using rule 42 (exp -> exp POWER exp .)
    LT              reduce using rule 42 (exp -> exp POWER exp .)
    GT              reduce using rule 42 (exp -> exp POWER exp .)
    LE              reduce using rule 42 (exp -> exp POWER exp .)
    GE              reduce using rule 42 (exp -> exp POWER exp .)
    PLUS            reduce using rule 42 (exp -> exp POWER exp .)
    MINUS           reduce using rule 42 (exp -> exp POWER exp .)
    TIMES           reduce using rule 42 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 42 (exp -> exp POWER exp .)
    POWER           reduce using rule 42 (exp -> exp POWER exp .)
    MOD             reduce using rule 42 (exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 42 (exp -> exp POWER exp .)
    FUNCTION        reduce using rule 42 (exp -> exp POWER exp .)
    IF              reduce using rule 42 (exp -> exp POWER exp .)
    WHILE           reduce using rule 42 (exp -> exp POWER exp .)
    IDENTIFIER      reduce using rule 42 (exp -> exp POWER exp .)
    RETURN          reduce using rule 42 (exp -> exp POWER exp .)
    VAR             reduce using rule 42 (exp -> exp POWER exp .)
    NUMBER          reduce using rule 42 (exp -> exp POWER exp .)
    STRING          reduce using rule 42 (exp -> exp POWER exp .)
    TRUE            reduce using rule 42 (exp -> exp POWER exp .)
    FALSE           reduce using rule 42 (exp -> exp POWER exp .)
    LOGICAL_NOT     reduce using rule 42 (exp -> exp POWER exp .)
    LPAREN          reduce using rule 42 (exp -> exp POWER exp .)
    $end            reduce using rule 42 (exp -> exp POWER exp .)
    RBRACE          reduce using rule 42 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 42 (exp -> exp POWER exp .)
    LBRACE          reduce using rule 42 (exp -> exp POWER exp .)
    COMMA           reduce using rule 42 (exp -> exp POWER exp .)

  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 33 ]
  ! MOD             [ shift and go to state 44 ]


state 65

    (37) exp -> exp GE exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 37 (exp -> exp GE exp .)
    LOGICAL_AND     reduce using rule 37 (exp -> exp GE exp .)
    LOGICAL_EQUAL   reduce using rule 37 (exp -> exp GE exp .)
    LT              reduce using rule 37 (exp -> exp GE exp .)
    GT              reduce using rule 37 (exp -> exp GE exp .)
    LE              reduce using rule 37 (exp -> exp GE exp .)
    GE              reduce using rule 37 (exp -> exp GE exp .)
    SEMICOLON       reduce using rule 37 (exp -> exp GE exp .)
    FUNCTION        reduce using rule 37 (exp -> exp GE exp .)
    IF              reduce using rule 37 (exp -> exp GE exp .)
    WHILE           reduce using rule 37 (exp -> exp GE exp .)
    IDENTIFIER      reduce using rule 37 (exp -> exp GE exp .)
    RETURN          reduce using rule 37 (exp -> exp GE exp .)
    VAR             reduce using rule 37 (exp -> exp GE exp .)
    NUMBER          reduce using rule 37 (exp -> exp GE exp .)
    STRING          reduce using rule 37 (exp -> exp GE exp .)
    TRUE            reduce using rule 37 (exp -> exp GE exp .)
    FALSE           reduce using rule 37 (exp -> exp GE exp .)
    LOGICAL_NOT     reduce using rule 37 (exp -> exp GE exp .)
    LPAREN          reduce using rule 37 (exp -> exp GE exp .)
    $end            reduce using rule 37 (exp -> exp GE exp .)
    RBRACE          reduce using rule 37 (exp -> exp GE exp .)
    RPAREN          reduce using rule 37 (exp -> exp GE exp .)
    LBRACE          reduce using rule 37 (exp -> exp GE exp .)
    COMMA           reduce using rule 37 (exp -> exp GE exp .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! PLUS            [ reduce using rule 37 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 37 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 37 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 37 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 37 (exp -> exp GE exp .) ]
  ! MOD             [ reduce using rule 37 (exp -> exp GE exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]


state 66

    (40) exp -> exp TIMES exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 40 (exp -> exp TIMES exp .)
    LOGICAL_AND     reduce using rule 40 (exp -> exp TIMES exp .)
    LOGICAL_EQUAL   reduce using rule 40 (exp -> exp TIMES exp .)
    LT              reduce using rule 40 (exp -> exp TIMES exp .)
    GT              reduce using rule 40 (exp -> exp TIMES exp .)
    LE              reduce using rule 40 (exp -> exp TIMES exp .)
    GE              reduce using rule 40 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 40 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 40 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 40 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 40 (exp -> exp TIMES exp .)
    MOD             reduce using rule 40 (exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 40 (exp -> exp TIMES exp .)
    FUNCTION        reduce using rule 40 (exp -> exp TIMES exp .)
    IF              reduce using rule 40 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 40 (exp -> exp TIMES exp .)
    IDENTIFIER      reduce using rule 40 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 40 (exp -> exp TIMES exp .)
    VAR             reduce using rule 40 (exp -> exp TIMES exp .)
    NUMBER          reduce using rule 40 (exp -> exp TIMES exp .)
    STRING          reduce using rule 40 (exp -> exp TIMES exp .)
    TRUE            reduce using rule 40 (exp -> exp TIMES exp .)
    FALSE           reduce using rule 40 (exp -> exp TIMES exp .)
    LOGICAL_NOT     reduce using rule 40 (exp -> exp TIMES exp .)
    LPAREN          reduce using rule 40 (exp -> exp TIMES exp .)
    $end            reduce using rule 40 (exp -> exp TIMES exp .)
    RBRACE          reduce using rule 40 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 40 (exp -> exp TIMES exp .)
    LBRACE          reduce using rule 40 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 40 (exp -> exp TIMES exp .)
    POWER           shift and go to state 33

  ! POWER           [ reduce using rule 40 (exp -> exp TIMES exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! MOD             [ shift and go to state 44 ]


state 67

    (31) exp -> exp LOGICAL_OR exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    SEMICOLON       reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    FUNCTION        reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    IF              reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    WHILE           reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    IDENTIFIER      reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    RETURN          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    VAR             reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    NUMBER          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    STRING          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    TRUE            reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    FALSE           reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    LOGICAL_NOT     reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    LPAREN          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    $end            reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    RBRACE          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    RPAREN          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    LBRACE          reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    COMMA           reduce using rule 31 (exp -> exp LOGICAL_OR exp .)
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! LOGICAL_AND     [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! LOGICAL_EQUAL   [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! LT              [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! GT              [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! LE              [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! GE              [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! PLUS            [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! MINUS           [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! TIMES           [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! DIVIDE          [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! POWER           [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! MOD             [ reduce using rule 31 (exp -> exp LOGICAL_OR exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]


state 68

    (34) exp -> exp LT exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 34 (exp -> exp LT exp .)
    LOGICAL_AND     reduce using rule 34 (exp -> exp LT exp .)
    LOGICAL_EQUAL   reduce using rule 34 (exp -> exp LT exp .)
    LT              reduce using rule 34 (exp -> exp LT exp .)
    GT              reduce using rule 34 (exp -> exp LT exp .)
    LE              reduce using rule 34 (exp -> exp LT exp .)
    GE              reduce using rule 34 (exp -> exp LT exp .)
    SEMICOLON       reduce using rule 34 (exp -> exp LT exp .)
    FUNCTION        reduce using rule 34 (exp -> exp LT exp .)
    IF              reduce using rule 34 (exp -> exp LT exp .)
    WHILE           reduce using rule 34 (exp -> exp LT exp .)
    IDENTIFIER      reduce using rule 34 (exp -> exp LT exp .)
    RETURN          reduce using rule 34 (exp -> exp LT exp .)
    VAR             reduce using rule 34 (exp -> exp LT exp .)
    NUMBER          reduce using rule 34 (exp -> exp LT exp .)
    STRING          reduce using rule 34 (exp -> exp LT exp .)
    TRUE            reduce using rule 34 (exp -> exp LT exp .)
    FALSE           reduce using rule 34 (exp -> exp LT exp .)
    LOGICAL_NOT     reduce using rule 34 (exp -> exp LT exp .)
    LPAREN          reduce using rule 34 (exp -> exp LT exp .)
    $end            reduce using rule 34 (exp -> exp LT exp .)
    RBRACE          reduce using rule 34 (exp -> exp LT exp .)
    RPAREN          reduce using rule 34 (exp -> exp LT exp .)
    LBRACE          reduce using rule 34 (exp -> exp LT exp .)
    COMMA           reduce using rule 34 (exp -> exp LT exp .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! PLUS            [ reduce using rule 34 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 34 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 34 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 34 (exp -> exp LT exp .) ]
  ! MOD             [ reduce using rule 34 (exp -> exp LT exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]


state 69

    (36) exp -> exp LE exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 36 (exp -> exp LE exp .)
    LOGICAL_AND     reduce using rule 36 (exp -> exp LE exp .)
    LOGICAL_EQUAL   reduce using rule 36 (exp -> exp LE exp .)
    LT              reduce using rule 36 (exp -> exp LE exp .)
    GT              reduce using rule 36 (exp -> exp LE exp .)
    LE              reduce using rule 36 (exp -> exp LE exp .)
    GE              reduce using rule 36 (exp -> exp LE exp .)
    SEMICOLON       reduce using rule 36 (exp -> exp LE exp .)
    FUNCTION        reduce using rule 36 (exp -> exp LE exp .)
    IF              reduce using rule 36 (exp -> exp LE exp .)
    WHILE           reduce using rule 36 (exp -> exp LE exp .)
    IDENTIFIER      reduce using rule 36 (exp -> exp LE exp .)
    RETURN          reduce using rule 36 (exp -> exp LE exp .)
    VAR             reduce using rule 36 (exp -> exp LE exp .)
    NUMBER          reduce using rule 36 (exp -> exp LE exp .)
    STRING          reduce using rule 36 (exp -> exp LE exp .)
    TRUE            reduce using rule 36 (exp -> exp LE exp .)
    FALSE           reduce using rule 36 (exp -> exp LE exp .)
    LOGICAL_NOT     reduce using rule 36 (exp -> exp LE exp .)
    LPAREN          reduce using rule 36 (exp -> exp LE exp .)
    $end            reduce using rule 36 (exp -> exp LE exp .)
    RBRACE          reduce using rule 36 (exp -> exp LE exp .)
    RPAREN          reduce using rule 36 (exp -> exp LE exp .)
    LBRACE          reduce using rule 36 (exp -> exp LE exp .)
    COMMA           reduce using rule 36 (exp -> exp LE exp .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! PLUS            [ reduce using rule 36 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 36 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 36 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 36 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 36 (exp -> exp LE exp .) ]
  ! MOD             [ reduce using rule 36 (exp -> exp LE exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]


state 70

    (32) exp -> exp LOGICAL_AND exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    LOGICAL_AND     reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    SEMICOLON       reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    FUNCTION        reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    IF              reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    WHILE           reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    IDENTIFIER      reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    RETURN          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    VAR             reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    NUMBER          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    STRING          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    TRUE            reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    FALSE           reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    LOGICAL_NOT     reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    LPAREN          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    $end            reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    RBRACE          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    RPAREN          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    LBRACE          reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    COMMA           reduce using rule 32 (exp -> exp LOGICAL_AND exp .)
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! LOGICAL_EQUAL   [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! LT              [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! GT              [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! LE              [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! GE              [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! PLUS            [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! MINUS           [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! TIMES           [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! DIVIDE          [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! POWER           [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! MOD             [ reduce using rule 32 (exp -> exp LOGICAL_AND exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]


state 71

    (38) exp -> exp PLUS exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 38 (exp -> exp PLUS exp .)
    LOGICAL_AND     reduce using rule 38 (exp -> exp PLUS exp .)
    LOGICAL_EQUAL   reduce using rule 38 (exp -> exp PLUS exp .)
    LT              reduce using rule 38 (exp -> exp PLUS exp .)
    GT              reduce using rule 38 (exp -> exp PLUS exp .)
    LE              reduce using rule 38 (exp -> exp PLUS exp .)
    GE              reduce using rule 38 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 38 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 38 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 38 (exp -> exp PLUS exp .)
    FUNCTION        reduce using rule 38 (exp -> exp PLUS exp .)
    IF              reduce using rule 38 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 38 (exp -> exp PLUS exp .)
    IDENTIFIER      reduce using rule 38 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 38 (exp -> exp PLUS exp .)
    VAR             reduce using rule 38 (exp -> exp PLUS exp .)
    NUMBER          reduce using rule 38 (exp -> exp PLUS exp .)
    STRING          reduce using rule 38 (exp -> exp PLUS exp .)
    TRUE            reduce using rule 38 (exp -> exp PLUS exp .)
    FALSE           reduce using rule 38 (exp -> exp PLUS exp .)
    LOGICAL_NOT     reduce using rule 38 (exp -> exp PLUS exp .)
    LPAREN          reduce using rule 38 (exp -> exp PLUS exp .)
    $end            reduce using rule 38 (exp -> exp PLUS exp .)
    RBRACE          reduce using rule 38 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 38 (exp -> exp PLUS exp .)
    LBRACE          reduce using rule 38 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 38 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! TIMES           [ reduce using rule 38 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 38 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 38 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 38 (exp -> exp PLUS exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]


state 72

    (39) exp -> exp MINUS exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 39 (exp -> exp MINUS exp .)
    LOGICAL_AND     reduce using rule 39 (exp -> exp MINUS exp .)
    LOGICAL_EQUAL   reduce using rule 39 (exp -> exp MINUS exp .)
    LT              reduce using rule 39 (exp -> exp MINUS exp .)
    GT              reduce using rule 39 (exp -> exp MINUS exp .)
    LE              reduce using rule 39 (exp -> exp MINUS exp .)
    GE              reduce using rule 39 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 39 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 39 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 39 (exp -> exp MINUS exp .)
    FUNCTION        reduce using rule 39 (exp -> exp MINUS exp .)
    IF              reduce using rule 39 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 39 (exp -> exp MINUS exp .)
    IDENTIFIER      reduce using rule 39 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 39 (exp -> exp MINUS exp .)
    VAR             reduce using rule 39 (exp -> exp MINUS exp .)
    NUMBER          reduce using rule 39 (exp -> exp MINUS exp .)
    STRING          reduce using rule 39 (exp -> exp MINUS exp .)
    TRUE            reduce using rule 39 (exp -> exp MINUS exp .)
    FALSE           reduce using rule 39 (exp -> exp MINUS exp .)
    LOGICAL_NOT     reduce using rule 39 (exp -> exp MINUS exp .)
    LPAREN          reduce using rule 39 (exp -> exp MINUS exp .)
    $end            reduce using rule 39 (exp -> exp MINUS exp .)
    RBRACE          reduce using rule 39 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 39 (exp -> exp MINUS exp .)
    LBRACE          reduce using rule 39 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 39 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44

  ! TIMES           [ reduce using rule 39 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 39 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 39 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 39 (exp -> exp MINUS exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]


state 73

    (43) exp -> exp MOD exp .
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 43 (exp -> exp MOD exp .)
    LOGICAL_AND     reduce using rule 43 (exp -> exp MOD exp .)
    LOGICAL_EQUAL   reduce using rule 43 (exp -> exp MOD exp .)
    LT              reduce using rule 43 (exp -> exp MOD exp .)
    GT              reduce using rule 43 (exp -> exp MOD exp .)
    LE              reduce using rule 43 (exp -> exp MOD exp .)
    GE              reduce using rule 43 (exp -> exp MOD exp .)
    PLUS            reduce using rule 43 (exp -> exp MOD exp .)
    MINUS           reduce using rule 43 (exp -> exp MOD exp .)
    TIMES           reduce using rule 43 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 43 (exp -> exp MOD exp .)
    MOD             reduce using rule 43 (exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 43 (exp -> exp MOD exp .)
    FUNCTION        reduce using rule 43 (exp -> exp MOD exp .)
    IF              reduce using rule 43 (exp -> exp MOD exp .)
    WHILE           reduce using rule 43 (exp -> exp MOD exp .)
    IDENTIFIER      reduce using rule 43 (exp -> exp MOD exp .)
    RETURN          reduce using rule 43 (exp -> exp MOD exp .)
    VAR             reduce using rule 43 (exp -> exp MOD exp .)
    NUMBER          reduce using rule 43 (exp -> exp MOD exp .)
    STRING          reduce using rule 43 (exp -> exp MOD exp .)
    TRUE            reduce using rule 43 (exp -> exp MOD exp .)
    FALSE           reduce using rule 43 (exp -> exp MOD exp .)
    LOGICAL_NOT     reduce using rule 43 (exp -> exp MOD exp .)
    LPAREN          reduce using rule 43 (exp -> exp MOD exp .)
    $end            reduce using rule 43 (exp -> exp MOD exp .)
    RBRACE          reduce using rule 43 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 43 (exp -> exp MOD exp .)
    LBRACE          reduce using rule 43 (exp -> exp MOD exp .)
    COMMA           reduce using rule 43 (exp -> exp MOD exp .)
    POWER           shift and go to state 33

  ! POWER           [ reduce using rule 43 (exp -> exp MOD exp .) ]
  ! LOGICAL_OR      [ shift and go to state 37 ]
  ! LOGICAL_AND     [ shift and go to state 40 ]
  ! LOGICAL_EQUAL   [ shift and go to state 30 ]
  ! LT              [ shift and go to state 38 ]
  ! GT              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 39 ]
  ! GE              [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! MOD             [ shift and go to state 44 ]


state 74

    (9) compoundstmt -> LBRACE stmts . RBRACE

    RBRACE          shift and go to state 86


state 75

    (10) stmts -> sstmt . stmts
    (10) stmts -> . sstmt stmts
    (15) stmts -> .
    (16) sstmt -> . IF exp stmt_or_compound optsemi
    (17) sstmt -> . WHILE exp compoundstmt optsemi
    (18) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (19) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (20) sstmt -> . RETURN exp optsemi
    (21) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (22) sstmt -> . exp optsemi
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    RBRACE          reduce using rule 15 (stmts -> .)
    IF              shift and go to state 13
    WHILE           shift and go to state 2
    IDENTIFIER      shift and go to state 5
    RETURN          shift and go to state 1
    VAR             shift and go to state 11
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    sstmt                          shift and go to state 75
    stmts                          shift and go to state 87
    exp                            shift and go to state 16

state 76

    (17) sstmt -> WHILE exp compoundstmt optsemi .

    SEMICOLON       reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    FUNCTION        reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    IF              reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    WHILE           reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    IDENTIFIER      reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    RETURN          reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    VAR             reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    NUMBER          reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    STRING          reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    TRUE            reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    FALSE           reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    LOGICAL_NOT     reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    LPAREN          reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    $end            reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)
    RBRACE          reduce using rule 17 (sstmt -> WHILE exp compoundstmt optsemi .)


state 77

    (19) sstmt -> IDENTIFIER EQUAL exp optsemi .

    SEMICOLON       reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    FUNCTION        reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    IF              reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    WHILE           reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    IDENTIFIER      reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    RETURN          reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    VAR             reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    NUMBER          reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    STRING          reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    TRUE            reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    FALSE           reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    LOGICAL_NOT     reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    LPAREN          reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    $end            reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    RBRACE          reduce using rule 19 (sstmt -> IDENTIFIER EQUAL exp optsemi .)


state 78

    (44) exp -> IDENTIFIER LPAREN optargs RPAREN .

    LOGICAL_OR      reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_AND     reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_EQUAL   reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LT              reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    GT              reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LE              reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    GE              reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    PLUS            reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    MINUS           reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    TIMES           reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    DIVIDE          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    POWER           reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    MOD             reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    SEMICOLON       reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    FUNCTION        reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    IF              reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    WHILE           reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    IDENTIFIER      reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    RETURN          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    VAR             reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    NUMBER          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    STRING          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    TRUE            reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    FALSE           reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_NOT     reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LPAREN          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    $end            reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    RBRACE          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    RPAREN          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LBRACE          reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    COMMA           reduce using rule 44 (exp -> IDENTIFIER LPAREN optargs RPAREN .)


state 79

    (47) args -> exp COMMA . args
    (47) args -> . exp COMMA args
    (48) args -> . exp
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 17
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    args                           shift and go to state 88
    exp                            shift and go to state 51

state 80

    (7) params -> IDENTIFIER COMMA . params
    (7) params -> . IDENTIFIER COMMA params
    (8) params -> . IDENTIFIER

    IDENTIFIER      shift and go to state 53

    params                         shift and go to state 89

state 81

    (30) exp -> FUNCTION LPAREN optparams RPAREN . compoundstmt
    (9) compoundstmt -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 46

    compoundstmt                   shift and go to state 90

state 82

    (3) element -> FUNCTION IDENTIFIER LPAREN optparams . RPAREN compoundstmt

    RPAREN          shift and go to state 91


state 83

    (21) sstmt -> VAR IDENTIFIER EQUAL exp . optsemi
    (31) exp -> exp . LOGICAL_OR exp
    (32) exp -> exp . LOGICAL_AND exp
    (33) exp -> exp . LOGICAL_EQUAL exp
    (34) exp -> exp . LT exp
    (35) exp -> exp . GT exp
    (36) exp -> exp . LE exp
    (37) exp -> exp . GE exp
    (38) exp -> exp . PLUS exp
    (39) exp -> exp . MINUS exp
    (40) exp -> exp . TIMES exp
    (41) exp -> exp . DIVIDE exp
    (42) exp -> exp . POWER exp
    (43) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 37
    LOGICAL_AND     shift and go to state 40
    LOGICAL_EQUAL   shift and go to state 30
    LT              shift and go to state 38
    GT              shift and go to state 31
    LE              shift and go to state 39
    GE              shift and go to state 35
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 36
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    MOD             shift and go to state 44
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 92

state 84

    (16) sstmt -> IF exp stmt_or_compound optsemi .

    SEMICOLON       reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    FUNCTION        reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    IF              reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    WHILE           reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    IDENTIFIER      reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    RETURN          reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    VAR             reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    NUMBER          reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    STRING          reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    TRUE            reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    FALSE           reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    LOGICAL_NOT     reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    LPAREN          reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    $end            reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)
    RBRACE          reduce using rule 16 (sstmt -> IF exp stmt_or_compound optsemi .)


state 85

    (18) sstmt -> IF exp compoundstmt ELSE . stmt_or_compound optsemi
    (11) stmt_or_compound -> . sstmt
    (12) stmt_or_compound -> . compoundstmt
    (16) sstmt -> . IF exp stmt_or_compound optsemi
    (17) sstmt -> . WHILE exp compoundstmt optsemi
    (18) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (19) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (20) sstmt -> . RETURN exp optsemi
    (21) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (22) sstmt -> . exp optsemi
    (9) compoundstmt -> . LBRACE stmts RBRACE
    (23) exp -> . IDENTIFIER
    (24) exp -> . NUMBER
    (25) exp -> . STRING
    (26) exp -> . TRUE
    (27) exp -> . FALSE
    (28) exp -> . LOGICAL_NOT exp
    (29) exp -> . LPAREN exp RPAREN
    (30) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (31) exp -> . exp LOGICAL_OR exp
    (32) exp -> . exp LOGICAL_AND exp
    (33) exp -> . exp LOGICAL_EQUAL exp
    (34) exp -> . exp LT exp
    (35) exp -> . exp GT exp
    (36) exp -> . exp LE exp
    (37) exp -> . exp GE exp
    (38) exp -> . exp PLUS exp
    (39) exp -> . exp MINUS exp
    (40) exp -> . exp TIMES exp
    (41) exp -> . exp DIVIDE exp
    (42) exp -> . exp POWER exp
    (43) exp -> . exp MOD exp
    (44) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IF              shift and go to state 13
    WHILE           shift and go to state 2
    IDENTIFIER      shift and go to state 5
    RETURN          shift and go to state 1
    VAR             shift and go to state 11
    LBRACE          shift and go to state 46
    NUMBER          shift and go to state 9
    STRING          shift and go to state 7
    TRUE            shift and go to state 3
    FALSE           shift and go to state 14
    LOGICAL_NOT     shift and go to state 12
    LPAREN          shift and go to state 10
    FUNCTION        shift and go to state 18

    stmt_or_compound               shift and go to state 93
    sstmt                          shift and go to state 58
    exp                            shift and go to state 16
    compoundstmt                   shift and go to state 94

state 86

    (9) compoundstmt -> LBRACE stmts RBRACE .

    SEMICOLON       reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    FUNCTION        reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    IF              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    WHILE           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    IDENTIFIER      reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    RETURN          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    VAR             reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    NUMBER          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    STRING          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    TRUE            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    FALSE           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_NOT     reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LPAREN          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    $end            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    ELSE            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_OR      reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_AND     reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_EQUAL   reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LT              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    GT              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LE              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    GE              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    PLUS            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    MINUS           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    TIMES           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    DIVIDE          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    POWER           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    MOD             reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LBRACE          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    RPAREN          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    COMMA           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)


state 87

    (10) stmts -> sstmt stmts .

    RBRACE          reduce using rule 10 (stmts -> sstmt stmts .)


state 88

    (47) args -> exp COMMA args .

    RPAREN          reduce using rule 47 (args -> exp COMMA args .)


state 89

    (7) params -> IDENTIFIER COMMA params .

    RPAREN          reduce using rule 7 (params -> IDENTIFIER COMMA params .)


state 90

    (30) exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .

    LOGICAL_OR      reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_AND     reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_EQUAL   reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LT              reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    GT              reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LE              reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    GE              reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    PLUS            reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    MINUS           reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    TIMES           reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    DIVIDE          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    POWER           reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    MOD             reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    SEMICOLON       reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    FUNCTION        reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    IF              reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    WHILE           reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    IDENTIFIER      reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    RETURN          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    VAR             reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    NUMBER          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    STRING          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    TRUE            reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    FALSE           reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_NOT     reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LPAREN          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    $end            reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    RBRACE          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    RPAREN          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LBRACE          reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    COMMA           reduce using rule 30 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)


state 91

    (3) element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN . compoundstmt
    (9) compoundstmt -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 46

    compoundstmt                   shift and go to state 95

state 92

    (21) sstmt -> VAR IDENTIFIER EQUAL exp optsemi .

    SEMICOLON       reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    FUNCTION        reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    IF              reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    WHILE           reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    IDENTIFIER      reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    RETURN          reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    VAR             reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    NUMBER          reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    STRING          reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    TRUE            reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    FALSE           reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    LOGICAL_NOT     reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    LPAREN          reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    $end            reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    RBRACE          reduce using rule 21 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)


state 93

    (18) sstmt -> IF exp compoundstmt ELSE stmt_or_compound . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 43

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 96

state 94

    (12) stmt_or_compound -> compoundstmt .

    SEMICOLON       reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FUNCTION        reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IF              reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    WHILE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IDENTIFIER      reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RETURN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    VAR             reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    NUMBER          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    STRING          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    TRUE            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FALSE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LOGICAL_NOT     reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LPAREN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    $end            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RBRACE          reduce using rule 12 (stmt_or_compound -> compoundstmt .)


state 95

    (3) element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .

    FUNCTION        reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    IF              reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    WHILE           reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    IDENTIFIER      reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    RETURN          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    VAR             reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    NUMBER          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    STRING          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    TRUE            reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    FALSE           reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_NOT     reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    LPAREN          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    $end            reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)


state 96

    (18) sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .

    SEMICOLON       reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    FUNCTION        reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    IF              reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    WHILE           reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    IDENTIFIER      reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    RETURN          reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    VAR             reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    NUMBER          reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    STRING          reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    TRUE            reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    FALSE           reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    LOGICAL_NOT     reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    LPAREN          reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    $end            reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    RBRACE          reduce using rule 18 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 5 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 16 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 17 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 19 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 47 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 48 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 59 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 83 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 93 resolved as shift
