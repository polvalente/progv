Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> progv
Rule 1     progv -> element progv
Rule 2     progv -> <empty>
Rule 3     element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt
Rule 4     element -> sstmt
Rule 5     optparams -> params
Rule 6     optparams -> <empty>
Rule 7     params -> IDENTIFIER COMMA params
Rule 8     params -> IDENTIFIER
Rule 9     compoundstmt -> LBRACE stmts RBRACE
Rule 10    stmts -> sstmt stmts
Rule 11    stmt_or_compound -> sstmt
Rule 12    stmt_or_compound -> compoundstmt
Rule 13    optsemi -> <empty>
Rule 14    optsemi -> SEMICOLON
Rule 15    stmts -> <empty>
Rule 16    sstmt -> BREAK
Rule 17    sstmt -> CONTINUE
Rule 18    sstmt -> IF exp stmt_or_compound optsemi
Rule 19    sstmt -> WHILE exp stmt_or_compound optsemi
Rule 20    sstmt -> DO compoundstmt WHILE exp optsemi
Rule 21    sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi
Rule 22    sstmt -> IDENTIFIER EQUAL exp optsemi
Rule 23    sstmt -> RETURN exp optsemi
Rule 24    sstmt -> VAR IDENTIFIER EQUAL exp optsemi
Rule 25    sstmt -> exp optsemi
Rule 26    assign_or_var -> IDENTIFIER EQUAL exp
Rule 27    assign_or_var -> VAR IDENTIFIER EQUAL exp
Rule 28    assign_or_var_stmt -> sstmt
Rule 29    assign_or_stmt -> IDENTIFIER EQUAL exp
Rule 30    assign_or_var -> <empty>
Rule 31    sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
Rule 32    exp -> IDENTIFIER
Rule 33    exp -> NUMBER
Rule 34    exp -> STRING
Rule 35    exp -> TRUE
Rule 36    exp -> FALSE
Rule 37    exp -> LOGICAL_NOT exp
Rule 38    exp -> LPAREN exp RPAREN
Rule 39    exp -> FUNCTION LPAREN optparams RPAREN compoundstmt
Rule 40    exp -> exp LOGICAL_OR exp
Rule 41    exp -> exp LOGICAL_AND exp
Rule 42    exp -> exp LOGICAL_EQUAL exp
Rule 43    exp -> exp LOGICAL_DIFF exp
Rule 44    exp -> exp LT exp
Rule 45    exp -> exp GT exp
Rule 46    exp -> exp LE exp
Rule 47    exp -> exp GE exp
Rule 48    exp -> exp PLUS exp
Rule 49    exp -> exp MINUS exp
Rule 50    exp -> exp TIMES exp
Rule 51    exp -> exp DIVIDE exp
Rule 52    exp -> exp POWER exp
Rule 53    exp -> exp MOD exp
Rule 54    exp -> IDENTIFIER LPAREN optargs RPAREN
Rule 55    optargs -> args
Rule 56    optargs -> <empty>
Rule 57    args -> exp COMMA args
Rule 58    args -> exp

Terminals, with rules where they appear

BREAK                : 16
COMMA                : 7 57
CONTINUE             : 17
DIVIDE               : 51
DO                   : 20
ELSE                 : 21
EQUAL                : 22 24 26 27 29
FALSE                : 36
FOR                  : 31
FUNCTION             : 3 39
GE                   : 47
GT                   : 45
IDENTIFIER           : 3 7 8 22 24 26 27 29 32 54
IF                   : 18 21
LBRACE               : 9
LE                   : 46
LOGICAL_AND          : 41
LOGICAL_DIFF         : 43
LOGICAL_EQUAL        : 42
LOGICAL_NOT          : 37
LOGICAL_OR           : 40
LPAREN               : 3 31 38 39 54
LT                   : 44
MINUS                : 49
MOD                  : 53
NUMBER               : 33
PLUS                 : 48
POWER                : 52
RBRACE               : 9
RETURN               : 23
RPAREN               : 3 31 38 39 54
SEMICOLON            : 14 31 31
STRING               : 34
TIMES                : 50
TRUE                 : 35
VAR                  : 24 27
WHILE                : 19 20
error                : 

Nonterminals, with rules where they appear

args                 : 55 57
assign_or_stmt       : 31
assign_or_var        : 31
assign_or_var_stmt   : 
compoundstmt         : 3 12 20 21 39
element              : 1
exp                  : 18 19 20 21 22 23 24 25 26 27 29 31 37 38 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 57 58
optargs              : 54
optparams            : 3 39
optsemi              : 18 19 20 21 22 23 24 25 31
params               : 5 7
progv                : 1 0
sstmt                : 4 10 11 28
stmt_or_compound     : 18 19 21 31
stmts                : 9 10

Parsing method: LALR

state 0

    (0) S' -> . progv
    (1) progv -> . element progv
    (2) progv -> .
    (3) element -> . FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt
    (4) element -> . sstmt
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    $end            reduce using rule 2 (progv -> .)
    FUNCTION        shift and go to state 7
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12

    progv                          shift and go to state 10
    sstmt                          shift and go to state 5
    element                        shift and go to state 17
    exp                            shift and go to state 20

state 1

    (20) sstmt -> DO . compoundstmt WHILE exp optsemi
    (9) compoundstmt -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 21

    compoundstmt                   shift and go to state 22

state 2

    (23) sstmt -> RETURN . exp optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 25

state 3

    (19) sstmt -> WHILE . exp stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 26

state 4

    (35) exp -> TRUE .

    LOGICAL_OR      reduce using rule 35 (exp -> TRUE .)
    LOGICAL_AND     reduce using rule 35 (exp -> TRUE .)
    LOGICAL_EQUAL   reduce using rule 35 (exp -> TRUE .)
    LOGICAL_DIFF    reduce using rule 35 (exp -> TRUE .)
    LT              reduce using rule 35 (exp -> TRUE .)
    GT              reduce using rule 35 (exp -> TRUE .)
    LE              reduce using rule 35 (exp -> TRUE .)
    GE              reduce using rule 35 (exp -> TRUE .)
    PLUS            reduce using rule 35 (exp -> TRUE .)
    MINUS           reduce using rule 35 (exp -> TRUE .)
    TIMES           reduce using rule 35 (exp -> TRUE .)
    DIVIDE          reduce using rule 35 (exp -> TRUE .)
    POWER           reduce using rule 35 (exp -> TRUE .)
    MOD             reduce using rule 35 (exp -> TRUE .)
    SEMICOLON       reduce using rule 35 (exp -> TRUE .)
    FUNCTION        reduce using rule 35 (exp -> TRUE .)
    BREAK           reduce using rule 35 (exp -> TRUE .)
    CONTINUE        reduce using rule 35 (exp -> TRUE .)
    IF              reduce using rule 35 (exp -> TRUE .)
    WHILE           reduce using rule 35 (exp -> TRUE .)
    DO              reduce using rule 35 (exp -> TRUE .)
    IDENTIFIER      reduce using rule 35 (exp -> TRUE .)
    RETURN          reduce using rule 35 (exp -> TRUE .)
    VAR             reduce using rule 35 (exp -> TRUE .)
    FOR             reduce using rule 35 (exp -> TRUE .)
    NUMBER          reduce using rule 35 (exp -> TRUE .)
    STRING          reduce using rule 35 (exp -> TRUE .)
    TRUE            reduce using rule 35 (exp -> TRUE .)
    FALSE           reduce using rule 35 (exp -> TRUE .)
    LOGICAL_NOT     reduce using rule 35 (exp -> TRUE .)
    LPAREN          reduce using rule 35 (exp -> TRUE .)
    $end            reduce using rule 35 (exp -> TRUE .)
    RBRACE          reduce using rule 35 (exp -> TRUE .)
    LBRACE          reduce using rule 35 (exp -> TRUE .)
    RPAREN          reduce using rule 35 (exp -> TRUE .)
    COMMA           reduce using rule 35 (exp -> TRUE .)


state 5

    (4) element -> sstmt .

    FUNCTION        reduce using rule 4 (element -> sstmt .)
    BREAK           reduce using rule 4 (element -> sstmt .)
    CONTINUE        reduce using rule 4 (element -> sstmt .)
    IF              reduce using rule 4 (element -> sstmt .)
    WHILE           reduce using rule 4 (element -> sstmt .)
    DO              reduce using rule 4 (element -> sstmt .)
    IDENTIFIER      reduce using rule 4 (element -> sstmt .)
    RETURN          reduce using rule 4 (element -> sstmt .)
    VAR             reduce using rule 4 (element -> sstmt .)
    FOR             reduce using rule 4 (element -> sstmt .)
    NUMBER          reduce using rule 4 (element -> sstmt .)
    STRING          reduce using rule 4 (element -> sstmt .)
    TRUE            reduce using rule 4 (element -> sstmt .)
    FALSE           reduce using rule 4 (element -> sstmt .)
    LOGICAL_NOT     reduce using rule 4 (element -> sstmt .)
    LPAREN          reduce using rule 4 (element -> sstmt .)
    $end            reduce using rule 4 (element -> sstmt .)


state 6

    (22) sstmt -> IDENTIFIER . EQUAL exp optsemi
    (32) exp -> IDENTIFIER .
    (54) exp -> IDENTIFIER . LPAREN optargs RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    EQUAL           shift and go to state 27
    LOGICAL_OR      reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_EQUAL   reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_DIFF    reduce using rule 32 (exp -> IDENTIFIER .)
    LT              reduce using rule 32 (exp -> IDENTIFIER .)
    GT              reduce using rule 32 (exp -> IDENTIFIER .)
    LE              reduce using rule 32 (exp -> IDENTIFIER .)
    GE              reduce using rule 32 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 32 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 32 (exp -> IDENTIFIER .)
    TIMES           reduce using rule 32 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 32 (exp -> IDENTIFIER .)
    POWER           reduce using rule 32 (exp -> IDENTIFIER .)
    MOD             reduce using rule 32 (exp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (exp -> IDENTIFIER .)
    FUNCTION        reduce using rule 32 (exp -> IDENTIFIER .)
    BREAK           reduce using rule 32 (exp -> IDENTIFIER .)
    CONTINUE        reduce using rule 32 (exp -> IDENTIFIER .)
    IF              reduce using rule 32 (exp -> IDENTIFIER .)
    WHILE           reduce using rule 32 (exp -> IDENTIFIER .)
    DO              reduce using rule 32 (exp -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 32 (exp -> IDENTIFIER .)
    RETURN          reduce using rule 32 (exp -> IDENTIFIER .)
    VAR             reduce using rule 32 (exp -> IDENTIFIER .)
    FOR             reduce using rule 32 (exp -> IDENTIFIER .)
    NUMBER          reduce using rule 32 (exp -> IDENTIFIER .)
    STRING          reduce using rule 32 (exp -> IDENTIFIER .)
    TRUE            reduce using rule 32 (exp -> IDENTIFIER .)
    FALSE           reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 32 (exp -> IDENTIFIER .)
    $end            reduce using rule 32 (exp -> IDENTIFIER .)
    RBRACE          reduce using rule 32 (exp -> IDENTIFIER .)
    LPAREN          shift and go to state 28

  ! LPAREN          [ reduce using rule 32 (exp -> IDENTIFIER .) ]


state 7

    (3) element -> FUNCTION . IDENTIFIER LPAREN optparams RPAREN compoundstmt
    (39) exp -> FUNCTION . LPAREN optparams RPAREN compoundstmt

    IDENTIFIER      shift and go to state 30
    LPAREN          shift and go to state 29


state 8

    (34) exp -> STRING .

    LOGICAL_OR      reduce using rule 34 (exp -> STRING .)
    LOGICAL_AND     reduce using rule 34 (exp -> STRING .)
    LOGICAL_EQUAL   reduce using rule 34 (exp -> STRING .)
    LOGICAL_DIFF    reduce using rule 34 (exp -> STRING .)
    LT              reduce using rule 34 (exp -> STRING .)
    GT              reduce using rule 34 (exp -> STRING .)
    LE              reduce using rule 34 (exp -> STRING .)
    GE              reduce using rule 34 (exp -> STRING .)
    PLUS            reduce using rule 34 (exp -> STRING .)
    MINUS           reduce using rule 34 (exp -> STRING .)
    TIMES           reduce using rule 34 (exp -> STRING .)
    DIVIDE          reduce using rule 34 (exp -> STRING .)
    POWER           reduce using rule 34 (exp -> STRING .)
    MOD             reduce using rule 34 (exp -> STRING .)
    SEMICOLON       reduce using rule 34 (exp -> STRING .)
    FUNCTION        reduce using rule 34 (exp -> STRING .)
    BREAK           reduce using rule 34 (exp -> STRING .)
    CONTINUE        reduce using rule 34 (exp -> STRING .)
    IF              reduce using rule 34 (exp -> STRING .)
    WHILE           reduce using rule 34 (exp -> STRING .)
    DO              reduce using rule 34 (exp -> STRING .)
    IDENTIFIER      reduce using rule 34 (exp -> STRING .)
    RETURN          reduce using rule 34 (exp -> STRING .)
    VAR             reduce using rule 34 (exp -> STRING .)
    FOR             reduce using rule 34 (exp -> STRING .)
    NUMBER          reduce using rule 34 (exp -> STRING .)
    STRING          reduce using rule 34 (exp -> STRING .)
    TRUE            reduce using rule 34 (exp -> STRING .)
    FALSE           reduce using rule 34 (exp -> STRING .)
    LOGICAL_NOT     reduce using rule 34 (exp -> STRING .)
    LPAREN          reduce using rule 34 (exp -> STRING .)
    $end            reduce using rule 34 (exp -> STRING .)
    RBRACE          reduce using rule 34 (exp -> STRING .)
    LBRACE          reduce using rule 34 (exp -> STRING .)
    RPAREN          reduce using rule 34 (exp -> STRING .)
    COMMA           reduce using rule 34 (exp -> STRING .)


state 9

    (31) sstmt -> FOR . LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi

    LPAREN          shift and go to state 31


state 10

    (0) S' -> progv .



state 11

    (33) exp -> NUMBER .

    LOGICAL_OR      reduce using rule 33 (exp -> NUMBER .)
    LOGICAL_AND     reduce using rule 33 (exp -> NUMBER .)
    LOGICAL_EQUAL   reduce using rule 33 (exp -> NUMBER .)
    LOGICAL_DIFF    reduce using rule 33 (exp -> NUMBER .)
    LT              reduce using rule 33 (exp -> NUMBER .)
    GT              reduce using rule 33 (exp -> NUMBER .)
    LE              reduce using rule 33 (exp -> NUMBER .)
    GE              reduce using rule 33 (exp -> NUMBER .)
    PLUS            reduce using rule 33 (exp -> NUMBER .)
    MINUS           reduce using rule 33 (exp -> NUMBER .)
    TIMES           reduce using rule 33 (exp -> NUMBER .)
    DIVIDE          reduce using rule 33 (exp -> NUMBER .)
    POWER           reduce using rule 33 (exp -> NUMBER .)
    MOD             reduce using rule 33 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 33 (exp -> NUMBER .)
    FUNCTION        reduce using rule 33 (exp -> NUMBER .)
    BREAK           reduce using rule 33 (exp -> NUMBER .)
    CONTINUE        reduce using rule 33 (exp -> NUMBER .)
    IF              reduce using rule 33 (exp -> NUMBER .)
    WHILE           reduce using rule 33 (exp -> NUMBER .)
    DO              reduce using rule 33 (exp -> NUMBER .)
    IDENTIFIER      reduce using rule 33 (exp -> NUMBER .)
    RETURN          reduce using rule 33 (exp -> NUMBER .)
    VAR             reduce using rule 33 (exp -> NUMBER .)
    FOR             reduce using rule 33 (exp -> NUMBER .)
    NUMBER          reduce using rule 33 (exp -> NUMBER .)
    STRING          reduce using rule 33 (exp -> NUMBER .)
    TRUE            reduce using rule 33 (exp -> NUMBER .)
    FALSE           reduce using rule 33 (exp -> NUMBER .)
    LOGICAL_NOT     reduce using rule 33 (exp -> NUMBER .)
    LPAREN          reduce using rule 33 (exp -> NUMBER .)
    $end            reduce using rule 33 (exp -> NUMBER .)
    RBRACE          reduce using rule 33 (exp -> NUMBER .)
    LBRACE          reduce using rule 33 (exp -> NUMBER .)
    RPAREN          reduce using rule 33 (exp -> NUMBER .)
    COMMA           reduce using rule 33 (exp -> NUMBER .)


state 12

    (38) exp -> LPAREN . exp RPAREN
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 32

state 13

    (24) sstmt -> VAR . IDENTIFIER EQUAL exp optsemi

    IDENTIFIER      shift and go to state 33


state 14

    (37) exp -> LOGICAL_NOT . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 34

state 15

    (18) sstmt -> IF . exp stmt_or_compound optsemi
    (21) sstmt -> IF . exp compoundstmt ELSE stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 35

state 16

    (36) exp -> FALSE .

    LOGICAL_OR      reduce using rule 36 (exp -> FALSE .)
    LOGICAL_AND     reduce using rule 36 (exp -> FALSE .)
    LOGICAL_EQUAL   reduce using rule 36 (exp -> FALSE .)
    LOGICAL_DIFF    reduce using rule 36 (exp -> FALSE .)
    LT              reduce using rule 36 (exp -> FALSE .)
    GT              reduce using rule 36 (exp -> FALSE .)
    LE              reduce using rule 36 (exp -> FALSE .)
    GE              reduce using rule 36 (exp -> FALSE .)
    PLUS            reduce using rule 36 (exp -> FALSE .)
    MINUS           reduce using rule 36 (exp -> FALSE .)
    TIMES           reduce using rule 36 (exp -> FALSE .)
    DIVIDE          reduce using rule 36 (exp -> FALSE .)
    POWER           reduce using rule 36 (exp -> FALSE .)
    MOD             reduce using rule 36 (exp -> FALSE .)
    SEMICOLON       reduce using rule 36 (exp -> FALSE .)
    FUNCTION        reduce using rule 36 (exp -> FALSE .)
    BREAK           reduce using rule 36 (exp -> FALSE .)
    CONTINUE        reduce using rule 36 (exp -> FALSE .)
    IF              reduce using rule 36 (exp -> FALSE .)
    WHILE           reduce using rule 36 (exp -> FALSE .)
    DO              reduce using rule 36 (exp -> FALSE .)
    IDENTIFIER      reduce using rule 36 (exp -> FALSE .)
    RETURN          reduce using rule 36 (exp -> FALSE .)
    VAR             reduce using rule 36 (exp -> FALSE .)
    FOR             reduce using rule 36 (exp -> FALSE .)
    NUMBER          reduce using rule 36 (exp -> FALSE .)
    STRING          reduce using rule 36 (exp -> FALSE .)
    TRUE            reduce using rule 36 (exp -> FALSE .)
    FALSE           reduce using rule 36 (exp -> FALSE .)
    LOGICAL_NOT     reduce using rule 36 (exp -> FALSE .)
    LPAREN          reduce using rule 36 (exp -> FALSE .)
    $end            reduce using rule 36 (exp -> FALSE .)
    RBRACE          reduce using rule 36 (exp -> FALSE .)
    LBRACE          reduce using rule 36 (exp -> FALSE .)
    RPAREN          reduce using rule 36 (exp -> FALSE .)
    COMMA           reduce using rule 36 (exp -> FALSE .)


state 17

    (1) progv -> element . progv
    (1) progv -> . element progv
    (2) progv -> .
    (3) element -> . FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt
    (4) element -> . sstmt
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    $end            reduce using rule 2 (progv -> .)
    FUNCTION        shift and go to state 7
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12

    progv                          shift and go to state 36
    sstmt                          shift and go to state 5
    element                        shift and go to state 17
    exp                            shift and go to state 20

state 18

    (16) sstmt -> BREAK .

    BREAK           reduce using rule 16 (sstmt -> BREAK .)
    CONTINUE        reduce using rule 16 (sstmt -> BREAK .)
    IF              reduce using rule 16 (sstmt -> BREAK .)
    WHILE           reduce using rule 16 (sstmt -> BREAK .)
    DO              reduce using rule 16 (sstmt -> BREAK .)
    IDENTIFIER      reduce using rule 16 (sstmt -> BREAK .)
    RETURN          reduce using rule 16 (sstmt -> BREAK .)
    VAR             reduce using rule 16 (sstmt -> BREAK .)
    FOR             reduce using rule 16 (sstmt -> BREAK .)
    NUMBER          reduce using rule 16 (sstmt -> BREAK .)
    STRING          reduce using rule 16 (sstmt -> BREAK .)
    TRUE            reduce using rule 16 (sstmt -> BREAK .)
    FALSE           reduce using rule 16 (sstmt -> BREAK .)
    LOGICAL_NOT     reduce using rule 16 (sstmt -> BREAK .)
    LPAREN          reduce using rule 16 (sstmt -> BREAK .)
    FUNCTION        reduce using rule 16 (sstmt -> BREAK .)
    RBRACE          reduce using rule 16 (sstmt -> BREAK .)
    SEMICOLON       reduce using rule 16 (sstmt -> BREAK .)
    $end            reduce using rule 16 (sstmt -> BREAK .)


state 19

    (17) sstmt -> CONTINUE .

    BREAK           reduce using rule 17 (sstmt -> CONTINUE .)
    CONTINUE        reduce using rule 17 (sstmt -> CONTINUE .)
    IF              reduce using rule 17 (sstmt -> CONTINUE .)
    WHILE           reduce using rule 17 (sstmt -> CONTINUE .)
    DO              reduce using rule 17 (sstmt -> CONTINUE .)
    IDENTIFIER      reduce using rule 17 (sstmt -> CONTINUE .)
    RETURN          reduce using rule 17 (sstmt -> CONTINUE .)
    VAR             reduce using rule 17 (sstmt -> CONTINUE .)
    FOR             reduce using rule 17 (sstmt -> CONTINUE .)
    NUMBER          reduce using rule 17 (sstmt -> CONTINUE .)
    STRING          reduce using rule 17 (sstmt -> CONTINUE .)
    TRUE            reduce using rule 17 (sstmt -> CONTINUE .)
    FALSE           reduce using rule 17 (sstmt -> CONTINUE .)
    LOGICAL_NOT     reduce using rule 17 (sstmt -> CONTINUE .)
    LPAREN          reduce using rule 17 (sstmt -> CONTINUE .)
    FUNCTION        reduce using rule 17 (sstmt -> CONTINUE .)
    RBRACE          reduce using rule 17 (sstmt -> CONTINUE .)
    SEMICOLON       reduce using rule 17 (sstmt -> CONTINUE .)
    $end            reduce using rule 17 (sstmt -> CONTINUE .)


state 20

    (25) sstmt -> exp . optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 41

state 21

    (9) compoundstmt -> LBRACE . stmts RBRACE
    (10) stmts -> . sstmt stmts
    (15) stmts -> .
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    RBRACE          reduce using rule 15 (stmts -> .)
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    stmts                          shift and go to state 53
    sstmt                          shift and go to state 54
    exp                            shift and go to state 20

state 22

    (20) sstmt -> DO compoundstmt . WHILE exp optsemi

    WHILE           shift and go to state 55


state 23

    (32) exp -> IDENTIFIER .
    (54) exp -> IDENTIFIER . LPAREN optargs RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LOGICAL_OR      reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_EQUAL   reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_DIFF    reduce using rule 32 (exp -> IDENTIFIER .)
    LT              reduce using rule 32 (exp -> IDENTIFIER .)
    GT              reduce using rule 32 (exp -> IDENTIFIER .)
    LE              reduce using rule 32 (exp -> IDENTIFIER .)
    GE              reduce using rule 32 (exp -> IDENTIFIER .)
    PLUS            reduce using rule 32 (exp -> IDENTIFIER .)
    MINUS           reduce using rule 32 (exp -> IDENTIFIER .)
    TIMES           reduce using rule 32 (exp -> IDENTIFIER .)
    DIVIDE          reduce using rule 32 (exp -> IDENTIFIER .)
    POWER           reduce using rule 32 (exp -> IDENTIFIER .)
    MOD             reduce using rule 32 (exp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (exp -> IDENTIFIER .)
    FUNCTION        reduce using rule 32 (exp -> IDENTIFIER .)
    BREAK           reduce using rule 32 (exp -> IDENTIFIER .)
    CONTINUE        reduce using rule 32 (exp -> IDENTIFIER .)
    IF              reduce using rule 32 (exp -> IDENTIFIER .)
    WHILE           reduce using rule 32 (exp -> IDENTIFIER .)
    DO              reduce using rule 32 (exp -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 32 (exp -> IDENTIFIER .)
    RETURN          reduce using rule 32 (exp -> IDENTIFIER .)
    VAR             reduce using rule 32 (exp -> IDENTIFIER .)
    FOR             reduce using rule 32 (exp -> IDENTIFIER .)
    NUMBER          reduce using rule 32 (exp -> IDENTIFIER .)
    STRING          reduce using rule 32 (exp -> IDENTIFIER .)
    TRUE            reduce using rule 32 (exp -> IDENTIFIER .)
    FALSE           reduce using rule 32 (exp -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 32 (exp -> IDENTIFIER .)
    $end            reduce using rule 32 (exp -> IDENTIFIER .)
    RBRACE          reduce using rule 32 (exp -> IDENTIFIER .)
    LBRACE          reduce using rule 32 (exp -> IDENTIFIER .)
    RPAREN          reduce using rule 32 (exp -> IDENTIFIER .)
    COMMA           reduce using rule 32 (exp -> IDENTIFIER .)
    LPAREN          shift and go to state 28

  ! LPAREN          [ reduce using rule 32 (exp -> IDENTIFIER .) ]


state 24

    (39) exp -> FUNCTION . LPAREN optparams RPAREN compoundstmt

    LPAREN          shift and go to state 29


state 25

    (23) sstmt -> RETURN exp . optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 56

state 26

    (19) sstmt -> WHILE exp . stmt_or_compound optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (11) stmt_or_compound -> . sstmt
    (12) stmt_or_compound -> . compoundstmt
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (9) compoundstmt -> . LBRACE stmts RBRACE
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    LBRACE          shift and go to state 21
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    stmt_or_compound               shift and go to state 58
    sstmt                          shift and go to state 57
    exp                            shift and go to state 20
    compoundstmt                   shift and go to state 59

state 27

    (22) sstmt -> IDENTIFIER EQUAL . exp optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 60

state 28

    (54) exp -> IDENTIFIER LPAREN . optargs RPAREN
    (55) optargs -> . args
    (56) optargs -> .
    (57) args -> . exp COMMA args
    (58) args -> . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    RPAREN          reduce using rule 56 (optargs -> .)
    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    args                           shift and go to state 62
    exp                            shift and go to state 63
    optargs                        shift and go to state 61

state 29

    (39) exp -> FUNCTION LPAREN . optparams RPAREN compoundstmt
    (5) optparams -> . params
    (6) optparams -> .
    (7) params -> . IDENTIFIER COMMA params
    (8) params -> . IDENTIFIER

    RPAREN          reduce using rule 6 (optparams -> .)
    IDENTIFIER      shift and go to state 65

    params                         shift and go to state 64
    optparams                      shift and go to state 66

state 30

    (3) element -> FUNCTION IDENTIFIER . LPAREN optparams RPAREN compoundstmt

    LPAREN          shift and go to state 67


state 31

    (31) sstmt -> FOR LPAREN . assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (26) assign_or_var -> . IDENTIFIER EQUAL exp
    (27) assign_or_var -> . VAR IDENTIFIER EQUAL exp
    (30) assign_or_var -> .

    IDENTIFIER      shift and go to state 69
    VAR             shift and go to state 68
    SEMICOLON       reduce using rule 30 (assign_or_var -> .)

    assign_or_var                  shift and go to state 70

state 32

    (38) exp -> LPAREN exp . RPAREN
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    RPAREN          shift and go to state 71
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52


state 33

    (24) sstmt -> VAR IDENTIFIER . EQUAL exp optsemi

    EQUAL           shift and go to state 72


state 34

    (37) exp -> LOGICAL_NOT exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LOGICAL_AND     reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LOGICAL_EQUAL   reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LOGICAL_DIFF    reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LT              reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    GT              reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LE              reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    GE              reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    PLUS            reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    MINUS           reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    TIMES           reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    DIVIDE          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    POWER           reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    MOD             reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    SEMICOLON       reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    FUNCTION        reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    BREAK           reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    CONTINUE        reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    IF              reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    WHILE           reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    DO              reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    IDENTIFIER      reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    RETURN          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    VAR             reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    FOR             reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    NUMBER          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    STRING          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    TRUE            reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    FALSE           reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LOGICAL_NOT     reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LPAREN          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    $end            reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    RBRACE          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    LBRACE          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    RPAREN          reduce using rule 37 (exp -> LOGICAL_NOT exp .)
    COMMA           reduce using rule 37 (exp -> LOGICAL_NOT exp .)

  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! TIMES           [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! POWER           [ shift and go to state 40 ]
  ! MOD             [ shift and go to state 52 ]


state 35

    (18) sstmt -> IF exp . stmt_or_compound optsemi
    (21) sstmt -> IF exp . compoundstmt ELSE stmt_or_compound optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (11) stmt_or_compound -> . sstmt
    (12) stmt_or_compound -> . compoundstmt
    (9) compoundstmt -> . LBRACE stmts RBRACE
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    LBRACE          shift and go to state 21
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    stmt_or_compound               shift and go to state 73
    sstmt                          shift and go to state 57
    exp                            shift and go to state 20
    compoundstmt                   shift and go to state 74

state 36

    (1) progv -> element progv .

    $end            reduce using rule 1 (progv -> element progv .)


state 37

    (42) exp -> exp LOGICAL_EQUAL . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 75

state 38

    (45) exp -> exp GT . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 76

state 39

    (51) exp -> exp DIVIDE . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 77

state 40

    (52) exp -> exp POWER . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 78

state 41

    (25) sstmt -> exp optsemi .

    BREAK           reduce using rule 25 (sstmt -> exp optsemi .)
    CONTINUE        reduce using rule 25 (sstmt -> exp optsemi .)
    IF              reduce using rule 25 (sstmt -> exp optsemi .)
    WHILE           reduce using rule 25 (sstmt -> exp optsemi .)
    DO              reduce using rule 25 (sstmt -> exp optsemi .)
    IDENTIFIER      reduce using rule 25 (sstmt -> exp optsemi .)
    RETURN          reduce using rule 25 (sstmt -> exp optsemi .)
    VAR             reduce using rule 25 (sstmt -> exp optsemi .)
    FOR             reduce using rule 25 (sstmt -> exp optsemi .)
    NUMBER          reduce using rule 25 (sstmt -> exp optsemi .)
    STRING          reduce using rule 25 (sstmt -> exp optsemi .)
    TRUE            reduce using rule 25 (sstmt -> exp optsemi .)
    FALSE           reduce using rule 25 (sstmt -> exp optsemi .)
    LOGICAL_NOT     reduce using rule 25 (sstmt -> exp optsemi .)
    LPAREN          reduce using rule 25 (sstmt -> exp optsemi .)
    FUNCTION        reduce using rule 25 (sstmt -> exp optsemi .)
    RBRACE          reduce using rule 25 (sstmt -> exp optsemi .)
    SEMICOLON       reduce using rule 25 (sstmt -> exp optsemi .)
    $end            reduce using rule 25 (sstmt -> exp optsemi .)


state 42

    (47) exp -> exp GE . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 79

state 43

    (50) exp -> exp TIMES . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 80

state 44

    (40) exp -> exp LOGICAL_OR . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 81

state 45

    (44) exp -> exp LT . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 82

state 46

    (46) exp -> exp LE . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 83

state 47

    (41) exp -> exp LOGICAL_AND . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 84

state 48

    (43) exp -> exp LOGICAL_DIFF . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 85

state 49

    (48) exp -> exp PLUS . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 86

state 50

    (49) exp -> exp MINUS . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 87

state 51

    (14) optsemi -> SEMICOLON .

    FUNCTION        reduce using rule 14 (optsemi -> SEMICOLON .)
    BREAK           reduce using rule 14 (optsemi -> SEMICOLON .)
    CONTINUE        reduce using rule 14 (optsemi -> SEMICOLON .)
    IF              reduce using rule 14 (optsemi -> SEMICOLON .)
    WHILE           reduce using rule 14 (optsemi -> SEMICOLON .)
    DO              reduce using rule 14 (optsemi -> SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (optsemi -> SEMICOLON .)
    RETURN          reduce using rule 14 (optsemi -> SEMICOLON .)
    VAR             reduce using rule 14 (optsemi -> SEMICOLON .)
    FOR             reduce using rule 14 (optsemi -> SEMICOLON .)
    NUMBER          reduce using rule 14 (optsemi -> SEMICOLON .)
    STRING          reduce using rule 14 (optsemi -> SEMICOLON .)
    TRUE            reduce using rule 14 (optsemi -> SEMICOLON .)
    FALSE           reduce using rule 14 (optsemi -> SEMICOLON .)
    LOGICAL_NOT     reduce using rule 14 (optsemi -> SEMICOLON .)
    LPAREN          reduce using rule 14 (optsemi -> SEMICOLON .)
    $end            reduce using rule 14 (optsemi -> SEMICOLON .)
    RBRACE          reduce using rule 14 (optsemi -> SEMICOLON .)
    SEMICOLON       reduce using rule 14 (optsemi -> SEMICOLON .)


state 52

    (53) exp -> exp MOD . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 88

state 53

    (9) compoundstmt -> LBRACE stmts . RBRACE

    RBRACE          shift and go to state 89


state 54

    (10) stmts -> sstmt . stmts
    (10) stmts -> . sstmt stmts
    (15) stmts -> .
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    RBRACE          reduce using rule 15 (stmts -> .)
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    sstmt                          shift and go to state 54
    stmts                          shift and go to state 90
    exp                            shift and go to state 20

state 55

    (20) sstmt -> DO compoundstmt WHILE . exp optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 91

state 56

    (23) sstmt -> RETURN exp optsemi .

    BREAK           reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    CONTINUE        reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    IF              reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    WHILE           reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    DO              reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    IDENTIFIER      reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    RETURN          reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    VAR             reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    FOR             reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    NUMBER          reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    STRING          reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    TRUE            reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    FALSE           reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    LOGICAL_NOT     reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    LPAREN          reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    FUNCTION        reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    RBRACE          reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    SEMICOLON       reduce using rule 23 (sstmt -> RETURN exp optsemi .)
    $end            reduce using rule 23 (sstmt -> RETURN exp optsemi .)


state 57

    (11) stmt_or_compound -> sstmt .

    SEMICOLON       reduce using rule 11 (stmt_or_compound -> sstmt .)
    FUNCTION        reduce using rule 11 (stmt_or_compound -> sstmt .)
    BREAK           reduce using rule 11 (stmt_or_compound -> sstmt .)
    CONTINUE        reduce using rule 11 (stmt_or_compound -> sstmt .)
    IF              reduce using rule 11 (stmt_or_compound -> sstmt .)
    WHILE           reduce using rule 11 (stmt_or_compound -> sstmt .)
    DO              reduce using rule 11 (stmt_or_compound -> sstmt .)
    IDENTIFIER      reduce using rule 11 (stmt_or_compound -> sstmt .)
    RETURN          reduce using rule 11 (stmt_or_compound -> sstmt .)
    VAR             reduce using rule 11 (stmt_or_compound -> sstmt .)
    FOR             reduce using rule 11 (stmt_or_compound -> sstmt .)
    NUMBER          reduce using rule 11 (stmt_or_compound -> sstmt .)
    STRING          reduce using rule 11 (stmt_or_compound -> sstmt .)
    TRUE            reduce using rule 11 (stmt_or_compound -> sstmt .)
    FALSE           reduce using rule 11 (stmt_or_compound -> sstmt .)
    LOGICAL_NOT     reduce using rule 11 (stmt_or_compound -> sstmt .)
    LPAREN          reduce using rule 11 (stmt_or_compound -> sstmt .)
    $end            reduce using rule 11 (stmt_or_compound -> sstmt .)
    RBRACE          reduce using rule 11 (stmt_or_compound -> sstmt .)


state 58

    (19) sstmt -> WHILE exp stmt_or_compound . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 92

state 59

    (12) stmt_or_compound -> compoundstmt .

    SEMICOLON       reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FUNCTION        reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    BREAK           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    CONTINUE        reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IF              reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    WHILE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    DO              reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IDENTIFIER      reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RETURN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    VAR             reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FOR             reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    NUMBER          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    STRING          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    TRUE            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FALSE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LOGICAL_NOT     reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LPAREN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    $end            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RBRACE          reduce using rule 12 (stmt_or_compound -> compoundstmt .)


state 60

    (22) sstmt -> IDENTIFIER EQUAL exp . optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 93

state 61

    (54) exp -> IDENTIFIER LPAREN optargs . RPAREN

    RPAREN          shift and go to state 94


state 62

    (55) optargs -> args .

    RPAREN          reduce using rule 55 (optargs -> args .)


state 63

    (57) args -> exp . COMMA args
    (58) args -> exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    COMMA           shift and go to state 95
    RPAREN          reduce using rule 58 (args -> exp .)
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52


state 64

    (5) optparams -> params .

    RPAREN          reduce using rule 5 (optparams -> params .)


state 65

    (7) params -> IDENTIFIER . COMMA params
    (8) params -> IDENTIFIER .

    COMMA           shift and go to state 96
    RPAREN          reduce using rule 8 (params -> IDENTIFIER .)


state 66

    (39) exp -> FUNCTION LPAREN optparams . RPAREN compoundstmt

    RPAREN          shift and go to state 97


state 67

    (3) element -> FUNCTION IDENTIFIER LPAREN . optparams RPAREN compoundstmt
    (5) optparams -> . params
    (6) optparams -> .
    (7) params -> . IDENTIFIER COMMA params
    (8) params -> . IDENTIFIER

    RPAREN          reduce using rule 6 (optparams -> .)
    IDENTIFIER      shift and go to state 65

    params                         shift and go to state 64
    optparams                      shift and go to state 98

state 68

    (27) assign_or_var -> VAR . IDENTIFIER EQUAL exp

    IDENTIFIER      shift and go to state 99


state 69

    (26) assign_or_var -> IDENTIFIER . EQUAL exp

    EQUAL           shift and go to state 100


state 70

    (31) sstmt -> FOR LPAREN assign_or_var . SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi

    SEMICOLON       shift and go to state 101


state 71

    (38) exp -> LPAREN exp RPAREN .

    LOGICAL_OR      reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LOGICAL_AND     reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LOGICAL_EQUAL   reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LOGICAL_DIFF    reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    FUNCTION        reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    BREAK           reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    CONTINUE        reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    IF              reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    WHILE           reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    DO              reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    IDENTIFIER      reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    RETURN          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    VAR             reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    FOR             reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    NUMBER          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    STRING          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    TRUE            reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    FALSE           reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LOGICAL_NOT     reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    $end            reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    RBRACE          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    LBRACE          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 38 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 38 (exp -> LPAREN exp RPAREN .)


state 72

    (24) sstmt -> VAR IDENTIFIER EQUAL . exp optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 102

state 73

    (18) sstmt -> IF exp stmt_or_compound . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 103

state 74

    (21) sstmt -> IF exp compoundstmt . ELSE stmt_or_compound optsemi
    (12) stmt_or_compound -> compoundstmt .

    ELSE            shift and go to state 104
    SEMICOLON       reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FUNCTION        reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    BREAK           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    CONTINUE        reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IF              reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    WHILE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    DO              reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    IDENTIFIER      reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RETURN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    VAR             reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FOR             reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    NUMBER          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    STRING          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    TRUE            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    FALSE           reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LOGICAL_NOT     reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    LPAREN          reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    $end            reduce using rule 12 (stmt_or_compound -> compoundstmt .)
    RBRACE          reduce using rule 12 (stmt_or_compound -> compoundstmt .)


state 75

    (42) exp -> exp LOGICAL_EQUAL exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_AND     reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_EQUAL   reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_DIFF    reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    SEMICOLON       reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    FUNCTION        reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    BREAK           reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    CONTINUE        reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    IF              reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    WHILE           reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    DO              reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    IDENTIFIER      reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    RETURN          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    VAR             reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    FOR             reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    NUMBER          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    STRING          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    TRUE            reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    FALSE           reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LOGICAL_NOT     reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LPAREN          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    $end            reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    RBRACE          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LBRACE          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    RPAREN          reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    COMMA           reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .)
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! LT              [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! GT              [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! LE              [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! GE              [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! PLUS            [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! POWER           [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp LOGICAL_EQUAL exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]


state 76

    (45) exp -> exp GT exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 45 (exp -> exp GT exp .)
    LOGICAL_AND     reduce using rule 45 (exp -> exp GT exp .)
    LOGICAL_EQUAL   reduce using rule 45 (exp -> exp GT exp .)
    LOGICAL_DIFF    reduce using rule 45 (exp -> exp GT exp .)
    LT              reduce using rule 45 (exp -> exp GT exp .)
    GT              reduce using rule 45 (exp -> exp GT exp .)
    LE              reduce using rule 45 (exp -> exp GT exp .)
    GE              reduce using rule 45 (exp -> exp GT exp .)
    SEMICOLON       reduce using rule 45 (exp -> exp GT exp .)
    FUNCTION        reduce using rule 45 (exp -> exp GT exp .)
    BREAK           reduce using rule 45 (exp -> exp GT exp .)
    CONTINUE        reduce using rule 45 (exp -> exp GT exp .)
    IF              reduce using rule 45 (exp -> exp GT exp .)
    WHILE           reduce using rule 45 (exp -> exp GT exp .)
    DO              reduce using rule 45 (exp -> exp GT exp .)
    IDENTIFIER      reduce using rule 45 (exp -> exp GT exp .)
    RETURN          reduce using rule 45 (exp -> exp GT exp .)
    VAR             reduce using rule 45 (exp -> exp GT exp .)
    FOR             reduce using rule 45 (exp -> exp GT exp .)
    NUMBER          reduce using rule 45 (exp -> exp GT exp .)
    STRING          reduce using rule 45 (exp -> exp GT exp .)
    TRUE            reduce using rule 45 (exp -> exp GT exp .)
    FALSE           reduce using rule 45 (exp -> exp GT exp .)
    LOGICAL_NOT     reduce using rule 45 (exp -> exp GT exp .)
    LPAREN          reduce using rule 45 (exp -> exp GT exp .)
    $end            reduce using rule 45 (exp -> exp GT exp .)
    RBRACE          reduce using rule 45 (exp -> exp GT exp .)
    LBRACE          reduce using rule 45 (exp -> exp GT exp .)
    RPAREN          reduce using rule 45 (exp -> exp GT exp .)
    COMMA           reduce using rule 45 (exp -> exp GT exp .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! PLUS            [ reduce using rule 45 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 45 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 45 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 45 (exp -> exp GT exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp GT exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]


state 77

    (51) exp -> exp DIVIDE exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 51 (exp -> exp DIVIDE exp .)
    LOGICAL_AND     reduce using rule 51 (exp -> exp DIVIDE exp .)
    LOGICAL_EQUAL   reduce using rule 51 (exp -> exp DIVIDE exp .)
    LOGICAL_DIFF    reduce using rule 51 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 51 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 51 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 51 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 51 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 51 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 51 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 51 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 51 (exp -> exp DIVIDE exp .)
    MOD             reduce using rule 51 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 51 (exp -> exp DIVIDE exp .)
    FUNCTION        reduce using rule 51 (exp -> exp DIVIDE exp .)
    BREAK           reduce using rule 51 (exp -> exp DIVIDE exp .)
    CONTINUE        reduce using rule 51 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 51 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 51 (exp -> exp DIVIDE exp .)
    DO              reduce using rule 51 (exp -> exp DIVIDE exp .)
    IDENTIFIER      reduce using rule 51 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 51 (exp -> exp DIVIDE exp .)
    VAR             reduce using rule 51 (exp -> exp DIVIDE exp .)
    FOR             reduce using rule 51 (exp -> exp DIVIDE exp .)
    NUMBER          reduce using rule 51 (exp -> exp DIVIDE exp .)
    STRING          reduce using rule 51 (exp -> exp DIVIDE exp .)
    TRUE            reduce using rule 51 (exp -> exp DIVIDE exp .)
    FALSE           reduce using rule 51 (exp -> exp DIVIDE exp .)
    LOGICAL_NOT     reduce using rule 51 (exp -> exp DIVIDE exp .)
    LPAREN          reduce using rule 51 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 51 (exp -> exp DIVIDE exp .)
    RBRACE          reduce using rule 51 (exp -> exp DIVIDE exp .)
    LBRACE          reduce using rule 51 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 51 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 51 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 40

  ! POWER           [ reduce using rule 51 (exp -> exp DIVIDE exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! TIMES           [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 52 ]


state 78

    (52) exp -> exp POWER exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 52 (exp -> exp POWER exp .)
    LOGICAL_AND     reduce using rule 52 (exp -> exp POWER exp .)
    LOGICAL_EQUAL   reduce using rule 52 (exp -> exp POWER exp .)
    LOGICAL_DIFF    reduce using rule 52 (exp -> exp POWER exp .)
    LT              reduce using rule 52 (exp -> exp POWER exp .)
    GT              reduce using rule 52 (exp -> exp POWER exp .)
    LE              reduce using rule 52 (exp -> exp POWER exp .)
    GE              reduce using rule 52 (exp -> exp POWER exp .)
    PLUS            reduce using rule 52 (exp -> exp POWER exp .)
    MINUS           reduce using rule 52 (exp -> exp POWER exp .)
    TIMES           reduce using rule 52 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 52 (exp -> exp POWER exp .)
    POWER           reduce using rule 52 (exp -> exp POWER exp .)
    MOD             reduce using rule 52 (exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 52 (exp -> exp POWER exp .)
    FUNCTION        reduce using rule 52 (exp -> exp POWER exp .)
    BREAK           reduce using rule 52 (exp -> exp POWER exp .)
    CONTINUE        reduce using rule 52 (exp -> exp POWER exp .)
    IF              reduce using rule 52 (exp -> exp POWER exp .)
    WHILE           reduce using rule 52 (exp -> exp POWER exp .)
    DO              reduce using rule 52 (exp -> exp POWER exp .)
    IDENTIFIER      reduce using rule 52 (exp -> exp POWER exp .)
    RETURN          reduce using rule 52 (exp -> exp POWER exp .)
    VAR             reduce using rule 52 (exp -> exp POWER exp .)
    FOR             reduce using rule 52 (exp -> exp POWER exp .)
    NUMBER          reduce using rule 52 (exp -> exp POWER exp .)
    STRING          reduce using rule 52 (exp -> exp POWER exp .)
    TRUE            reduce using rule 52 (exp -> exp POWER exp .)
    FALSE           reduce using rule 52 (exp -> exp POWER exp .)
    LOGICAL_NOT     reduce using rule 52 (exp -> exp POWER exp .)
    LPAREN          reduce using rule 52 (exp -> exp POWER exp .)
    $end            reduce using rule 52 (exp -> exp POWER exp .)
    RBRACE          reduce using rule 52 (exp -> exp POWER exp .)
    LBRACE          reduce using rule 52 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 52 (exp -> exp POWER exp .)
    COMMA           reduce using rule 52 (exp -> exp POWER exp .)

  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! TIMES           [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! POWER           [ shift and go to state 40 ]
  ! MOD             [ shift and go to state 52 ]


state 79

    (47) exp -> exp GE exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 47 (exp -> exp GE exp .)
    LOGICAL_AND     reduce using rule 47 (exp -> exp GE exp .)
    LOGICAL_EQUAL   reduce using rule 47 (exp -> exp GE exp .)
    LOGICAL_DIFF    reduce using rule 47 (exp -> exp GE exp .)
    LT              reduce using rule 47 (exp -> exp GE exp .)
    GT              reduce using rule 47 (exp -> exp GE exp .)
    LE              reduce using rule 47 (exp -> exp GE exp .)
    GE              reduce using rule 47 (exp -> exp GE exp .)
    SEMICOLON       reduce using rule 47 (exp -> exp GE exp .)
    FUNCTION        reduce using rule 47 (exp -> exp GE exp .)
    BREAK           reduce using rule 47 (exp -> exp GE exp .)
    CONTINUE        reduce using rule 47 (exp -> exp GE exp .)
    IF              reduce using rule 47 (exp -> exp GE exp .)
    WHILE           reduce using rule 47 (exp -> exp GE exp .)
    DO              reduce using rule 47 (exp -> exp GE exp .)
    IDENTIFIER      reduce using rule 47 (exp -> exp GE exp .)
    RETURN          reduce using rule 47 (exp -> exp GE exp .)
    VAR             reduce using rule 47 (exp -> exp GE exp .)
    FOR             reduce using rule 47 (exp -> exp GE exp .)
    NUMBER          reduce using rule 47 (exp -> exp GE exp .)
    STRING          reduce using rule 47 (exp -> exp GE exp .)
    TRUE            reduce using rule 47 (exp -> exp GE exp .)
    FALSE           reduce using rule 47 (exp -> exp GE exp .)
    LOGICAL_NOT     reduce using rule 47 (exp -> exp GE exp .)
    LPAREN          reduce using rule 47 (exp -> exp GE exp .)
    $end            reduce using rule 47 (exp -> exp GE exp .)
    RBRACE          reduce using rule 47 (exp -> exp GE exp .)
    LBRACE          reduce using rule 47 (exp -> exp GE exp .)
    RPAREN          reduce using rule 47 (exp -> exp GE exp .)
    COMMA           reduce using rule 47 (exp -> exp GE exp .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! PLUS            [ reduce using rule 47 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 47 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 47 (exp -> exp GE exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp GE exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]


state 80

    (50) exp -> exp TIMES exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 50 (exp -> exp TIMES exp .)
    LOGICAL_AND     reduce using rule 50 (exp -> exp TIMES exp .)
    LOGICAL_EQUAL   reduce using rule 50 (exp -> exp TIMES exp .)
    LOGICAL_DIFF    reduce using rule 50 (exp -> exp TIMES exp .)
    LT              reduce using rule 50 (exp -> exp TIMES exp .)
    GT              reduce using rule 50 (exp -> exp TIMES exp .)
    LE              reduce using rule 50 (exp -> exp TIMES exp .)
    GE              reduce using rule 50 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 50 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 50 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 50 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 50 (exp -> exp TIMES exp .)
    MOD             reduce using rule 50 (exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 50 (exp -> exp TIMES exp .)
    FUNCTION        reduce using rule 50 (exp -> exp TIMES exp .)
    BREAK           reduce using rule 50 (exp -> exp TIMES exp .)
    CONTINUE        reduce using rule 50 (exp -> exp TIMES exp .)
    IF              reduce using rule 50 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 50 (exp -> exp TIMES exp .)
    DO              reduce using rule 50 (exp -> exp TIMES exp .)
    IDENTIFIER      reduce using rule 50 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 50 (exp -> exp TIMES exp .)
    VAR             reduce using rule 50 (exp -> exp TIMES exp .)
    FOR             reduce using rule 50 (exp -> exp TIMES exp .)
    NUMBER          reduce using rule 50 (exp -> exp TIMES exp .)
    STRING          reduce using rule 50 (exp -> exp TIMES exp .)
    TRUE            reduce using rule 50 (exp -> exp TIMES exp .)
    FALSE           reduce using rule 50 (exp -> exp TIMES exp .)
    LOGICAL_NOT     reduce using rule 50 (exp -> exp TIMES exp .)
    LPAREN          reduce using rule 50 (exp -> exp TIMES exp .)
    $end            reduce using rule 50 (exp -> exp TIMES exp .)
    RBRACE          reduce using rule 50 (exp -> exp TIMES exp .)
    LBRACE          reduce using rule 50 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 50 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 50 (exp -> exp TIMES exp .)
    POWER           shift and go to state 40

  ! POWER           [ reduce using rule 50 (exp -> exp TIMES exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! TIMES           [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 52 ]


state 81

    (40) exp -> exp LOGICAL_OR exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    SEMICOLON       reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    FUNCTION        reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    BREAK           reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    CONTINUE        reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    IF              reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    WHILE           reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    DO              reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    IDENTIFIER      reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    RETURN          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    VAR             reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    FOR             reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    NUMBER          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    STRING          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    TRUE            reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    FALSE           reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    LOGICAL_NOT     reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    LPAREN          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    $end            reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    RBRACE          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    LBRACE          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    RPAREN          reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    COMMA           reduce using rule 40 (exp -> exp LOGICAL_OR exp .)
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! LOGICAL_AND     [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! LOGICAL_EQUAL   [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! LOGICAL_DIFF    [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! LT              [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! GT              [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! LE              [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! GE              [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! PLUS            [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! MINUS           [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! TIMES           [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! DIVIDE          [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! POWER           [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! MOD             [ reduce using rule 40 (exp -> exp LOGICAL_OR exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]


state 82

    (44) exp -> exp LT exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 44 (exp -> exp LT exp .)
    LOGICAL_AND     reduce using rule 44 (exp -> exp LT exp .)
    LOGICAL_EQUAL   reduce using rule 44 (exp -> exp LT exp .)
    LOGICAL_DIFF    reduce using rule 44 (exp -> exp LT exp .)
    LT              reduce using rule 44 (exp -> exp LT exp .)
    GT              reduce using rule 44 (exp -> exp LT exp .)
    LE              reduce using rule 44 (exp -> exp LT exp .)
    GE              reduce using rule 44 (exp -> exp LT exp .)
    SEMICOLON       reduce using rule 44 (exp -> exp LT exp .)
    FUNCTION        reduce using rule 44 (exp -> exp LT exp .)
    BREAK           reduce using rule 44 (exp -> exp LT exp .)
    CONTINUE        reduce using rule 44 (exp -> exp LT exp .)
    IF              reduce using rule 44 (exp -> exp LT exp .)
    WHILE           reduce using rule 44 (exp -> exp LT exp .)
    DO              reduce using rule 44 (exp -> exp LT exp .)
    IDENTIFIER      reduce using rule 44 (exp -> exp LT exp .)
    RETURN          reduce using rule 44 (exp -> exp LT exp .)
    VAR             reduce using rule 44 (exp -> exp LT exp .)
    FOR             reduce using rule 44 (exp -> exp LT exp .)
    NUMBER          reduce using rule 44 (exp -> exp LT exp .)
    STRING          reduce using rule 44 (exp -> exp LT exp .)
    TRUE            reduce using rule 44 (exp -> exp LT exp .)
    FALSE           reduce using rule 44 (exp -> exp LT exp .)
    LOGICAL_NOT     reduce using rule 44 (exp -> exp LT exp .)
    LPAREN          reduce using rule 44 (exp -> exp LT exp .)
    $end            reduce using rule 44 (exp -> exp LT exp .)
    RBRACE          reduce using rule 44 (exp -> exp LT exp .)
    LBRACE          reduce using rule 44 (exp -> exp LT exp .)
    RPAREN          reduce using rule 44 (exp -> exp LT exp .)
    COMMA           reduce using rule 44 (exp -> exp LT exp .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! PLUS            [ reduce using rule 44 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 44 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 44 (exp -> exp LT exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp LT exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]


state 83

    (46) exp -> exp LE exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 46 (exp -> exp LE exp .)
    LOGICAL_AND     reduce using rule 46 (exp -> exp LE exp .)
    LOGICAL_EQUAL   reduce using rule 46 (exp -> exp LE exp .)
    LOGICAL_DIFF    reduce using rule 46 (exp -> exp LE exp .)
    LT              reduce using rule 46 (exp -> exp LE exp .)
    GT              reduce using rule 46 (exp -> exp LE exp .)
    LE              reduce using rule 46 (exp -> exp LE exp .)
    GE              reduce using rule 46 (exp -> exp LE exp .)
    SEMICOLON       reduce using rule 46 (exp -> exp LE exp .)
    FUNCTION        reduce using rule 46 (exp -> exp LE exp .)
    BREAK           reduce using rule 46 (exp -> exp LE exp .)
    CONTINUE        reduce using rule 46 (exp -> exp LE exp .)
    IF              reduce using rule 46 (exp -> exp LE exp .)
    WHILE           reduce using rule 46 (exp -> exp LE exp .)
    DO              reduce using rule 46 (exp -> exp LE exp .)
    IDENTIFIER      reduce using rule 46 (exp -> exp LE exp .)
    RETURN          reduce using rule 46 (exp -> exp LE exp .)
    VAR             reduce using rule 46 (exp -> exp LE exp .)
    FOR             reduce using rule 46 (exp -> exp LE exp .)
    NUMBER          reduce using rule 46 (exp -> exp LE exp .)
    STRING          reduce using rule 46 (exp -> exp LE exp .)
    TRUE            reduce using rule 46 (exp -> exp LE exp .)
    FALSE           reduce using rule 46 (exp -> exp LE exp .)
    LOGICAL_NOT     reduce using rule 46 (exp -> exp LE exp .)
    LPAREN          reduce using rule 46 (exp -> exp LE exp .)
    $end            reduce using rule 46 (exp -> exp LE exp .)
    RBRACE          reduce using rule 46 (exp -> exp LE exp .)
    LBRACE          reduce using rule 46 (exp -> exp LE exp .)
    RPAREN          reduce using rule 46 (exp -> exp LE exp .)
    COMMA           reduce using rule 46 (exp -> exp LE exp .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! PLUS            [ reduce using rule 46 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 46 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 46 (exp -> exp LE exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp LE exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]


state 84

    (41) exp -> exp LOGICAL_AND exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    LOGICAL_AND     reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    SEMICOLON       reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    FUNCTION        reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    BREAK           reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    CONTINUE        reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    IF              reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    WHILE           reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    DO              reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    IDENTIFIER      reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    RETURN          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    VAR             reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    FOR             reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    NUMBER          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    STRING          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    TRUE            reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    FALSE           reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    LOGICAL_NOT     reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    LPAREN          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    $end            reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    RBRACE          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    LBRACE          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    RPAREN          reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    COMMA           reduce using rule 41 (exp -> exp LOGICAL_AND exp .)
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! LOGICAL_EQUAL   [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! LOGICAL_DIFF    [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! LT              [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! GT              [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! LE              [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! GE              [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! PLUS            [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! MINUS           [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! TIMES           [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! DIVIDE          [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! POWER           [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! MOD             [ reduce using rule 41 (exp -> exp LOGICAL_AND exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]


state 85

    (43) exp -> exp LOGICAL_DIFF exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LOGICAL_AND     reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LOGICAL_EQUAL   reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LOGICAL_DIFF    reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    SEMICOLON       reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    FUNCTION        reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    BREAK           reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    CONTINUE        reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    IF              reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    WHILE           reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    DO              reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    IDENTIFIER      reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    RETURN          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    VAR             reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    FOR             reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    NUMBER          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    STRING          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    TRUE            reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    FALSE           reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LOGICAL_NOT     reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LPAREN          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    $end            reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    RBRACE          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LBRACE          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    RPAREN          reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    COMMA           reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .)
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! LT              [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! GT              [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! LE              [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! GE              [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! PLUS            [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! MINUS           [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! TIMES           [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! POWER           [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp LOGICAL_DIFF exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]


state 86

    (48) exp -> exp PLUS exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 48 (exp -> exp PLUS exp .)
    LOGICAL_AND     reduce using rule 48 (exp -> exp PLUS exp .)
    LOGICAL_EQUAL   reduce using rule 48 (exp -> exp PLUS exp .)
    LOGICAL_DIFF    reduce using rule 48 (exp -> exp PLUS exp .)
    LT              reduce using rule 48 (exp -> exp PLUS exp .)
    GT              reduce using rule 48 (exp -> exp PLUS exp .)
    LE              reduce using rule 48 (exp -> exp PLUS exp .)
    GE              reduce using rule 48 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 48 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 48 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 48 (exp -> exp PLUS exp .)
    FUNCTION        reduce using rule 48 (exp -> exp PLUS exp .)
    BREAK           reduce using rule 48 (exp -> exp PLUS exp .)
    CONTINUE        reduce using rule 48 (exp -> exp PLUS exp .)
    IF              reduce using rule 48 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 48 (exp -> exp PLUS exp .)
    DO              reduce using rule 48 (exp -> exp PLUS exp .)
    IDENTIFIER      reduce using rule 48 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 48 (exp -> exp PLUS exp .)
    VAR             reduce using rule 48 (exp -> exp PLUS exp .)
    FOR             reduce using rule 48 (exp -> exp PLUS exp .)
    NUMBER          reduce using rule 48 (exp -> exp PLUS exp .)
    STRING          reduce using rule 48 (exp -> exp PLUS exp .)
    TRUE            reduce using rule 48 (exp -> exp PLUS exp .)
    FALSE           reduce using rule 48 (exp -> exp PLUS exp .)
    LOGICAL_NOT     reduce using rule 48 (exp -> exp PLUS exp .)
    LPAREN          reduce using rule 48 (exp -> exp PLUS exp .)
    $end            reduce using rule 48 (exp -> exp PLUS exp .)
    RBRACE          reduce using rule 48 (exp -> exp PLUS exp .)
    LBRACE          reduce using rule 48 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 48 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 48 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! TIMES           [ reduce using rule 48 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 48 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> exp PLUS exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]


state 87

    (49) exp -> exp MINUS exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 49 (exp -> exp MINUS exp .)
    LOGICAL_AND     reduce using rule 49 (exp -> exp MINUS exp .)
    LOGICAL_EQUAL   reduce using rule 49 (exp -> exp MINUS exp .)
    LOGICAL_DIFF    reduce using rule 49 (exp -> exp MINUS exp .)
    LT              reduce using rule 49 (exp -> exp MINUS exp .)
    GT              reduce using rule 49 (exp -> exp MINUS exp .)
    LE              reduce using rule 49 (exp -> exp MINUS exp .)
    GE              reduce using rule 49 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 49 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 49 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 49 (exp -> exp MINUS exp .)
    FUNCTION        reduce using rule 49 (exp -> exp MINUS exp .)
    BREAK           reduce using rule 49 (exp -> exp MINUS exp .)
    CONTINUE        reduce using rule 49 (exp -> exp MINUS exp .)
    IF              reduce using rule 49 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 49 (exp -> exp MINUS exp .)
    DO              reduce using rule 49 (exp -> exp MINUS exp .)
    IDENTIFIER      reduce using rule 49 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 49 (exp -> exp MINUS exp .)
    VAR             reduce using rule 49 (exp -> exp MINUS exp .)
    FOR             reduce using rule 49 (exp -> exp MINUS exp .)
    NUMBER          reduce using rule 49 (exp -> exp MINUS exp .)
    STRING          reduce using rule 49 (exp -> exp MINUS exp .)
    TRUE            reduce using rule 49 (exp -> exp MINUS exp .)
    FALSE           reduce using rule 49 (exp -> exp MINUS exp .)
    LOGICAL_NOT     reduce using rule 49 (exp -> exp MINUS exp .)
    LPAREN          reduce using rule 49 (exp -> exp MINUS exp .)
    $end            reduce using rule 49 (exp -> exp MINUS exp .)
    RBRACE          reduce using rule 49 (exp -> exp MINUS exp .)
    LBRACE          reduce using rule 49 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 49 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 49 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52

  ! TIMES           [ reduce using rule 49 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 49 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 49 (exp -> exp MINUS exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]


state 88

    (53) exp -> exp MOD exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    LOGICAL_OR      reduce using rule 53 (exp -> exp MOD exp .)
    LOGICAL_AND     reduce using rule 53 (exp -> exp MOD exp .)
    LOGICAL_EQUAL   reduce using rule 53 (exp -> exp MOD exp .)
    LOGICAL_DIFF    reduce using rule 53 (exp -> exp MOD exp .)
    LT              reduce using rule 53 (exp -> exp MOD exp .)
    GT              reduce using rule 53 (exp -> exp MOD exp .)
    LE              reduce using rule 53 (exp -> exp MOD exp .)
    GE              reduce using rule 53 (exp -> exp MOD exp .)
    PLUS            reduce using rule 53 (exp -> exp MOD exp .)
    MINUS           reduce using rule 53 (exp -> exp MOD exp .)
    TIMES           reduce using rule 53 (exp -> exp MOD exp .)
    DIVIDE          reduce using rule 53 (exp -> exp MOD exp .)
    MOD             reduce using rule 53 (exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 53 (exp -> exp MOD exp .)
    FUNCTION        reduce using rule 53 (exp -> exp MOD exp .)
    BREAK           reduce using rule 53 (exp -> exp MOD exp .)
    CONTINUE        reduce using rule 53 (exp -> exp MOD exp .)
    IF              reduce using rule 53 (exp -> exp MOD exp .)
    WHILE           reduce using rule 53 (exp -> exp MOD exp .)
    DO              reduce using rule 53 (exp -> exp MOD exp .)
    IDENTIFIER      reduce using rule 53 (exp -> exp MOD exp .)
    RETURN          reduce using rule 53 (exp -> exp MOD exp .)
    VAR             reduce using rule 53 (exp -> exp MOD exp .)
    FOR             reduce using rule 53 (exp -> exp MOD exp .)
    NUMBER          reduce using rule 53 (exp -> exp MOD exp .)
    STRING          reduce using rule 53 (exp -> exp MOD exp .)
    TRUE            reduce using rule 53 (exp -> exp MOD exp .)
    FALSE           reduce using rule 53 (exp -> exp MOD exp .)
    LOGICAL_NOT     reduce using rule 53 (exp -> exp MOD exp .)
    LPAREN          reduce using rule 53 (exp -> exp MOD exp .)
    $end            reduce using rule 53 (exp -> exp MOD exp .)
    RBRACE          reduce using rule 53 (exp -> exp MOD exp .)
    LBRACE          reduce using rule 53 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 53 (exp -> exp MOD exp .)
    COMMA           reduce using rule 53 (exp -> exp MOD exp .)
    POWER           shift and go to state 40

  ! POWER           [ reduce using rule 53 (exp -> exp MOD exp .) ]
  ! LOGICAL_OR      [ shift and go to state 44 ]
  ! LOGICAL_AND     [ shift and go to state 47 ]
  ! LOGICAL_EQUAL   [ shift and go to state 37 ]
  ! LOGICAL_DIFF    [ shift and go to state 48 ]
  ! LT              [ shift and go to state 45 ]
  ! GT              [ shift and go to state 38 ]
  ! LE              [ shift and go to state 46 ]
  ! GE              [ shift and go to state 42 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! TIMES           [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 52 ]


state 89

    (9) compoundstmt -> LBRACE stmts RBRACE .

    SEMICOLON       reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    FUNCTION        reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    BREAK           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    CONTINUE        reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    IF              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    WHILE           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    DO              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    IDENTIFIER      reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    RETURN          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    VAR             reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    FOR             reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    NUMBER          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    STRING          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    TRUE            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    FALSE           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_NOT     reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LPAREN          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    $end            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_OR      reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_AND     reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_EQUAL   reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LOGICAL_DIFF    reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LT              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    GT              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LE              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    GE              reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    PLUS            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    MINUS           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    TIMES           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    DIVIDE          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    POWER           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    MOD             reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    LBRACE          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    RPAREN          reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    COMMA           reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)
    ELSE            reduce using rule 9 (compoundstmt -> LBRACE stmts RBRACE .)


state 90

    (10) stmts -> sstmt stmts .

    RBRACE          reduce using rule 10 (stmts -> sstmt stmts .)


state 91

    (20) sstmt -> DO compoundstmt WHILE exp . optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 105

state 92

    (19) sstmt -> WHILE exp stmt_or_compound optsemi .

    BREAK           reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    CONTINUE        reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    IF              reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    WHILE           reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    DO              reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    IDENTIFIER      reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    RETURN          reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    VAR             reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    FOR             reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    NUMBER          reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    STRING          reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    TRUE            reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    FALSE           reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    LOGICAL_NOT     reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    LPAREN          reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    FUNCTION        reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    RBRACE          reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    SEMICOLON       reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)
    $end            reduce using rule 19 (sstmt -> WHILE exp stmt_or_compound optsemi .)


state 93

    (22) sstmt -> IDENTIFIER EQUAL exp optsemi .

    BREAK           reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    CONTINUE        reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    IF              reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    WHILE           reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    DO              reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    IDENTIFIER      reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    RETURN          reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    VAR             reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    FOR             reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    NUMBER          reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    STRING          reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    TRUE            reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    FALSE           reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    LOGICAL_NOT     reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    LPAREN          reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    FUNCTION        reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    RBRACE          reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    SEMICOLON       reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)
    $end            reduce using rule 22 (sstmt -> IDENTIFIER EQUAL exp optsemi .)


state 94

    (54) exp -> IDENTIFIER LPAREN optargs RPAREN .

    LOGICAL_OR      reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_AND     reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_EQUAL   reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_DIFF    reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LT              reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    GT              reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LE              reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    GE              reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    PLUS            reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    MINUS           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    TIMES           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    DIVIDE          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    POWER           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    MOD             reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    SEMICOLON       reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    FUNCTION        reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    BREAK           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    CONTINUE        reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    IF              reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    WHILE           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    DO              reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    IDENTIFIER      reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    RETURN          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    VAR             reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    FOR             reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    NUMBER          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    STRING          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    TRUE            reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    FALSE           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LOGICAL_NOT     reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LPAREN          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    $end            reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    RBRACE          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    LBRACE          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    RPAREN          reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)
    COMMA           reduce using rule 54 (exp -> IDENTIFIER LPAREN optargs RPAREN .)


state 95

    (57) args -> exp COMMA . args
    (57) args -> . exp COMMA args
    (58) args -> . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    args                           shift and go to state 106
    exp                            shift and go to state 63

state 96

    (7) params -> IDENTIFIER COMMA . params
    (7) params -> . IDENTIFIER COMMA params
    (8) params -> . IDENTIFIER

    IDENTIFIER      shift and go to state 65

    params                         shift and go to state 107

state 97

    (39) exp -> FUNCTION LPAREN optparams RPAREN . compoundstmt
    (9) compoundstmt -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 21

    compoundstmt                   shift and go to state 108

state 98

    (3) element -> FUNCTION IDENTIFIER LPAREN optparams . RPAREN compoundstmt

    RPAREN          shift and go to state 109


state 99

    (27) assign_or_var -> VAR IDENTIFIER . EQUAL exp

    EQUAL           shift and go to state 110


state 100

    (26) assign_or_var -> IDENTIFIER EQUAL . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 111

state 101

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON . exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 112

state 102

    (24) sstmt -> VAR IDENTIFIER EQUAL exp . optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 113

state 103

    (18) sstmt -> IF exp stmt_or_compound optsemi .

    BREAK           reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    CONTINUE        reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    IF              reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    WHILE           reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    DO              reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    IDENTIFIER      reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    RETURN          reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    VAR             reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    FOR             reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    NUMBER          reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    STRING          reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    TRUE            reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    FALSE           reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    LOGICAL_NOT     reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    LPAREN          reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    FUNCTION        reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    RBRACE          reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    SEMICOLON       reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)
    $end            reduce using rule 18 (sstmt -> IF exp stmt_or_compound optsemi .)


state 104

    (21) sstmt -> IF exp compoundstmt ELSE . stmt_or_compound optsemi
    (11) stmt_or_compound -> . sstmt
    (12) stmt_or_compound -> . compoundstmt
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (9) compoundstmt -> . LBRACE stmts RBRACE
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    LBRACE          shift and go to state 21
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    stmt_or_compound               shift and go to state 114
    sstmt                          shift and go to state 57
    exp                            shift and go to state 20
    compoundstmt                   shift and go to state 59

state 105

    (20) sstmt -> DO compoundstmt WHILE exp optsemi .

    BREAK           reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    CONTINUE        reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    IF              reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    WHILE           reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    DO              reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    IDENTIFIER      reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    RETURN          reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    VAR             reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    FOR             reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    NUMBER          reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    STRING          reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    TRUE            reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    FALSE           reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    LOGICAL_NOT     reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    LPAREN          reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    FUNCTION        reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    RBRACE          reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    SEMICOLON       reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)
    $end            reduce using rule 20 (sstmt -> DO compoundstmt WHILE exp optsemi .)


state 106

    (57) args -> exp COMMA args .

    RPAREN          reduce using rule 57 (args -> exp COMMA args .)


state 107

    (7) params -> IDENTIFIER COMMA params .

    RPAREN          reduce using rule 7 (params -> IDENTIFIER COMMA params .)


state 108

    (39) exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .

    LOGICAL_OR      reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_AND     reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_EQUAL   reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_DIFF    reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LT              reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    GT              reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LE              reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    GE              reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    PLUS            reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    MINUS           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    TIMES           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    DIVIDE          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    POWER           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    MOD             reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    SEMICOLON       reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    FUNCTION        reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    BREAK           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    CONTINUE        reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    IF              reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    WHILE           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    DO              reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    IDENTIFIER      reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    RETURN          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    VAR             reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    FOR             reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    NUMBER          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    STRING          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    TRUE            reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    FALSE           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_NOT     reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LPAREN          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    $end            reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    RBRACE          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    LBRACE          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    RPAREN          reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)
    COMMA           reduce using rule 39 (exp -> FUNCTION LPAREN optparams RPAREN compoundstmt .)


state 109

    (3) element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN . compoundstmt
    (9) compoundstmt -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 21

    compoundstmt                   shift and go to state 115

state 110

    (27) assign_or_var -> VAR IDENTIFIER EQUAL . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 116

state 111

    (26) assign_or_var -> IDENTIFIER EQUAL exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    SEMICOLON       reduce using rule 26 (assign_or_var -> IDENTIFIER EQUAL exp .)
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52


state 112

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON exp . SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    SEMICOLON       shift and go to state 117
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52


state 113

    (24) sstmt -> VAR IDENTIFIER EQUAL exp optsemi .

    BREAK           reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    CONTINUE        reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    IF              reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    WHILE           reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    DO              reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    IDENTIFIER      reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    RETURN          reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    VAR             reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    FOR             reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    NUMBER          reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    STRING          reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    TRUE            reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    FALSE           reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    LOGICAL_NOT     reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    LPAREN          reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    FUNCTION        reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    RBRACE          reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    SEMICOLON       reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)
    $end            reduce using rule 24 (sstmt -> VAR IDENTIFIER EQUAL exp optsemi .)


state 114

    (21) sstmt -> IF exp compoundstmt ELSE stmt_or_compound . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 118

state 115

    (3) element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .

    FUNCTION        reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    BREAK           reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    CONTINUE        reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    IF              reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    WHILE           reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    DO              reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    IDENTIFIER      reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    RETURN          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    VAR             reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    FOR             reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    NUMBER          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    STRING          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    TRUE            reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    FALSE           reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    LOGICAL_NOT     reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    LPAREN          reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)
    $end            reduce using rule 3 (element -> FUNCTION IDENTIFIER LPAREN optparams RPAREN compoundstmt .)


state 116

    (27) assign_or_var -> VAR IDENTIFIER EQUAL exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    SEMICOLON       reduce using rule 27 (assign_or_var -> VAR IDENTIFIER EQUAL exp .)
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52


state 117

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON . assign_or_stmt RPAREN stmt_or_compound optsemi
    (29) assign_or_stmt -> . IDENTIFIER EQUAL exp

    IDENTIFIER      shift and go to state 120

    assign_or_stmt                 shift and go to state 119

state 118

    (21) sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .

    BREAK           reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    CONTINUE        reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    IF              reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    WHILE           reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    DO              reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    IDENTIFIER      reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    RETURN          reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    VAR             reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    FOR             reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    NUMBER          reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    STRING          reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    TRUE            reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    FALSE           reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    LOGICAL_NOT     reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    LPAREN          reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    FUNCTION        reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    RBRACE          reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    SEMICOLON       reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)
    $end            reduce using rule 21 (sstmt -> IF exp compoundstmt ELSE stmt_or_compound optsemi .)


state 119

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt . RPAREN stmt_or_compound optsemi

    RPAREN          shift and go to state 121


state 120

    (29) assign_or_stmt -> IDENTIFIER . EQUAL exp

    EQUAL           shift and go to state 122


state 121

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN . stmt_or_compound optsemi
    (11) stmt_or_compound -> . sstmt
    (12) stmt_or_compound -> . compoundstmt
    (16) sstmt -> . BREAK
    (17) sstmt -> . CONTINUE
    (18) sstmt -> . IF exp stmt_or_compound optsemi
    (19) sstmt -> . WHILE exp stmt_or_compound optsemi
    (20) sstmt -> . DO compoundstmt WHILE exp optsemi
    (21) sstmt -> . IF exp compoundstmt ELSE stmt_or_compound optsemi
    (22) sstmt -> . IDENTIFIER EQUAL exp optsemi
    (23) sstmt -> . RETURN exp optsemi
    (24) sstmt -> . VAR IDENTIFIER EQUAL exp optsemi
    (25) sstmt -> . exp optsemi
    (31) sstmt -> . FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi
    (9) compoundstmt -> . LBRACE stmts RBRACE
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    IF              shift and go to state 15
    WHILE           shift and go to state 3
    DO              shift and go to state 1
    IDENTIFIER      shift and go to state 6
    RETURN          shift and go to state 2
    VAR             shift and go to state 13
    FOR             shift and go to state 9
    LBRACE          shift and go to state 21
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    stmt_or_compound               shift and go to state 123
    sstmt                          shift and go to state 57
    exp                            shift and go to state 20
    compoundstmt                   shift and go to state 59

state 122

    (29) assign_or_stmt -> IDENTIFIER EQUAL . exp
    (32) exp -> . IDENTIFIER
    (33) exp -> . NUMBER
    (34) exp -> . STRING
    (35) exp -> . TRUE
    (36) exp -> . FALSE
    (37) exp -> . LOGICAL_NOT exp
    (38) exp -> . LPAREN exp RPAREN
    (39) exp -> . FUNCTION LPAREN optparams RPAREN compoundstmt
    (40) exp -> . exp LOGICAL_OR exp
    (41) exp -> . exp LOGICAL_AND exp
    (42) exp -> . exp LOGICAL_EQUAL exp
    (43) exp -> . exp LOGICAL_DIFF exp
    (44) exp -> . exp LT exp
    (45) exp -> . exp GT exp
    (46) exp -> . exp LE exp
    (47) exp -> . exp GE exp
    (48) exp -> . exp PLUS exp
    (49) exp -> . exp MINUS exp
    (50) exp -> . exp TIMES exp
    (51) exp -> . exp DIVIDE exp
    (52) exp -> . exp POWER exp
    (53) exp -> . exp MOD exp
    (54) exp -> . IDENTIFIER LPAREN optargs RPAREN

    IDENTIFIER      shift and go to state 23
    NUMBER          shift and go to state 11
    STRING          shift and go to state 8
    TRUE            shift and go to state 4
    FALSE           shift and go to state 16
    LOGICAL_NOT     shift and go to state 14
    LPAREN          shift and go to state 12
    FUNCTION        shift and go to state 24

    exp                            shift and go to state 124

state 123

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound . optsemi
    (13) optsemi -> .
    (14) optsemi -> . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    FUNCTION        reduce using rule 13 (optsemi -> .)
    BREAK           reduce using rule 13 (optsemi -> .)
    CONTINUE        reduce using rule 13 (optsemi -> .)
    IF              reduce using rule 13 (optsemi -> .)
    WHILE           reduce using rule 13 (optsemi -> .)
    DO              reduce using rule 13 (optsemi -> .)
    IDENTIFIER      reduce using rule 13 (optsemi -> .)
    RETURN          reduce using rule 13 (optsemi -> .)
    VAR             reduce using rule 13 (optsemi -> .)
    FOR             reduce using rule 13 (optsemi -> .)
    NUMBER          reduce using rule 13 (optsemi -> .)
    STRING          reduce using rule 13 (optsemi -> .)
    TRUE            reduce using rule 13 (optsemi -> .)
    FALSE           reduce using rule 13 (optsemi -> .)
    LOGICAL_NOT     reduce using rule 13 (optsemi -> .)
    LPAREN          reduce using rule 13 (optsemi -> .)
    $end            reduce using rule 13 (optsemi -> .)
    RBRACE          reduce using rule 13 (optsemi -> .)
    SEMICOLON       shift and go to state 51

  ! SEMICOLON       [ reduce using rule 13 (optsemi -> .) ]

    optsemi                        shift and go to state 125

state 124

    (29) assign_or_stmt -> IDENTIFIER EQUAL exp .
    (40) exp -> exp . LOGICAL_OR exp
    (41) exp -> exp . LOGICAL_AND exp
    (42) exp -> exp . LOGICAL_EQUAL exp
    (43) exp -> exp . LOGICAL_DIFF exp
    (44) exp -> exp . LT exp
    (45) exp -> exp . GT exp
    (46) exp -> exp . LE exp
    (47) exp -> exp . GE exp
    (48) exp -> exp . PLUS exp
    (49) exp -> exp . MINUS exp
    (50) exp -> exp . TIMES exp
    (51) exp -> exp . DIVIDE exp
    (52) exp -> exp . POWER exp
    (53) exp -> exp . MOD exp

    RPAREN          reduce using rule 29 (assign_or_stmt -> IDENTIFIER EQUAL exp .)
    LOGICAL_OR      shift and go to state 44
    LOGICAL_AND     shift and go to state 47
    LOGICAL_EQUAL   shift and go to state 37
    LOGICAL_DIFF    shift and go to state 48
    LT              shift and go to state 45
    GT              shift and go to state 38
    LE              shift and go to state 46
    GE              shift and go to state 42
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 39
    POWER           shift and go to state 40
    MOD             shift and go to state 52


state 125

    (31) sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .

    BREAK           reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    CONTINUE        reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    IF              reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    WHILE           reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    DO              reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    IDENTIFIER      reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    RETURN          reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    VAR             reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    FOR             reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    NUMBER          reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    STRING          reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    TRUE            reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    FALSE           reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    LOGICAL_NOT     reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    LPAREN          reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    FUNCTION        reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    RBRACE          reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    SEMICOLON       reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)
    $end            reduce using rule 31 (sstmt -> FOR LPAREN assign_or_var SEMICOLON exp SEMICOLON assign_or_stmt RPAREN stmt_or_compound optsemi .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 6 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 20 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 23 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 25 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 58 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 60 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 73 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 91 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 102 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 114 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 123 resolved as shift
